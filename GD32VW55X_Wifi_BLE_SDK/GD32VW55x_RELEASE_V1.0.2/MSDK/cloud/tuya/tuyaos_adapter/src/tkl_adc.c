/**
 * @file tkl_adc.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "gd32vw55x.h"
#include "tkl_adc.h"
#include "gd32vw55x_adc.h"
#include "tuya_error_code.h"
#include "wrapper_os.h"
#include "dbg_print.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT
/**
 * @brief tuya kernel adc init
 *
 * @param[in] port_num: adc port number
 * @param[in] cfg: adc config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

#define ADC_DEV_NUM           1
#define ADC_DEV_CHNL_SUM      9
#define ADC_VOL_MAX           3300    // mv

typedef struct adc_env
{
    UINT16_T  ch_list;
    UINT8_T ch_nums;
    UINT32_T width;
    UINT8_T  adc_samp;
    TUYA_ADC_MODE_E mode;
    UINT16_T   conv_cnt;
} adc_env_t;

static adc_env_t adc_env_info =
{
    .ch_nums = 0,
    .width = 12,
};

static uint16_t tkl_adc_channel_sample(uint8_t channel)
{
    /* ADC software trigger enable */
    adc_software_trigger_enable(ADC_ROUTINE_CHANNEL);

    /* wait for ADC stability */
    sys_ms_sleep(1);

    /* wait the end of conversion flag */
    while(!adc_flag_get(ADC_FLAG_EOC));
    /* clear the end of conversion flag */
    adc_flag_clear(ADC_FLAG_EOC);
    /* return regular channel sample value */
    return (adc_routine_data_read());
}

static void tkl_adc_dma_config(uint32_t num, void *p_val)
{
    /* ADC_DMA_channel configuration */
    dma_single_data_parameter_struct dma_single_data_parameter;

    /* ADC DMA_channel configuration */
    dma_deinit(DMA_CH0);

    /* initialize DMA single data mode */
    dma_single_data_parameter.periph_addr         = (uint32_t)(&ADC_RDATA);
    dma_single_data_parameter.periph_inc          = DMA_PERIPH_INCREASE_DISABLE;
    dma_single_data_parameter.memory0_addr        = (uint32_t)p_val;
    dma_single_data_parameter.memory_inc          = DMA_MEMORY_INCREASE_ENABLE;
    dma_single_data_parameter.periph_memory_width = DMA_PERIPH_WIDTH_16BIT;
    dma_single_data_parameter.direction           = DMA_PERIPH_TO_MEMORY;
    dma_single_data_parameter.number              = num;
    dma_single_data_parameter.priority            = DMA_PRIORITY_HIGH;
    dma_single_data_mode_init(DMA_CH0, &dma_single_data_parameter);
    dma_channel_subperipheral_select(DMA_CH0, DMA_SUBPERI0);

    /* enable DMA circulation mode */
    dma_circulation_enable(DMA_CH0);
    /* enable DMA channel */
    dma_channel_enable(DMA_CH0);
}

OPERATE_RET tkl_adc_init(TUYA_ADC_NUM_E port_num, TUYA_ADC_BASE_CFG_T *cfg)
{
    uint32_t adc_samp = 0;
    uint8_t i;
    uint32_t pinA = 0;
    uint32_t pinB = 0;

    if (port_num > ADC_DEV_NUM || cfg->ch_nums > ADC_DEV_CHNL_SUM || cfg->ch_list.data == 0) {
        return OPRT_NOT_SUPPORTED;
    }

    adc_env_info.ch_list = 0;
    adc_env_info.ch_nums = cfg->ch_nums;
    adc_env_info.mode = cfg->mode;
    adc_env_info.conv_cnt = cfg->conv_cnt;


    /* enable ADC clock */
    rcu_periph_clock_enable(RCU_ADC);
    /* enable DMA clock */
    rcu_periph_clock_enable(RCU_DMA);
    /* config ADC clock */
    adc_clock_config(ADC_ADCCK_PCLK2_DIV4);      // 40M
    /* ADC data alignment config */
    adc_data_alignment_config(ADC_DATAALIGN_RIGHT);

    if (cfg->freq == 0) {
        adc_samp = 4;
    } else {
        adc_samp = 40000000 / cfg->freq;
    }

    if (adc_samp > 0 && adc_samp < (2 + adc_env_info.width)) {
        adc_env_info.adc_samp = 0;
    } else if (adc_samp >= (2 + adc_env_info.width) && adc_samp < (9 + adc_env_info.width)) {
        adc_env_info.adc_samp = 1;
    } else if (adc_samp >= (9 + adc_env_info.width) && adc_samp < (21 + adc_env_info.width)) {
        adc_env_info.adc_samp = 2;
    } else if (adc_samp >= (21 + adc_env_info.width) && adc_samp < (41 + adc_env_info.width)) {
        adc_env_info.adc_samp = 3;
    } else if (adc_samp >= (41 + adc_env_info.width) && adc_samp < (70 + adc_env_info.width)) {
        adc_env_info.adc_samp = 4;
    } else if (adc_samp >= (70 + adc_env_info.width) && adc_samp < (98 + adc_env_info.width)) {
        adc_env_info.adc_samp = 5;
    } else if (adc_samp >= (98 + adc_env_info.width) && adc_samp < (128 + adc_env_info.width)) {
        adc_env_info.adc_samp = 6;
    } else if (adc_samp >= (128 + adc_env_info.width) && adc_samp < (312 + adc_env_info.width)) {
        adc_env_info.adc_samp = 7;
    } else if (adc_samp >= (312 + adc_env_info.width)) {
        adc_env_info.adc_samp = 8;
    }

    if (cfg->ch_nums == ADC_DEV_CHNL_SUM) {
        pinA = GPIO_PIN_0|GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6|GPIO_PIN_7;
        pinB = GPIO_PIN_0;

        adc_env_info.ch_list = 0x01FF;
    } else {
        uint8_t num = 0;

        i = 0;
        while (num < cfg->ch_nums && i < ADC_DEV_CHNL_SUM) {
            if (cfg->ch_list.data & (1 << i)) {
                adc_env_info.ch_list |= 1 << i;
                if (i < 8) {
                    pinA |= 1 << i;
                } else {
                    pinB = GPIO_PIN_0;
                }
                num++;
            }
            i++;
        }

    }

    //dbg_print(NOTICE, "tkl_adc_init pinA 0x%x, pinB 0x%x \r\n", pinA, pinB);
    if (pinA != 0) {
        /* enable GPIO clock */
        rcu_periph_clock_enable(RCU_GPIOA);
        gpio_mode_set(GPIOA, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, pinA);
    }

    if (pinB != 0) {
        /* enable GPIO clock */
        rcu_periph_clock_enable(RCU_GPIOB);
        gpio_mode_set(GPIOB, GPIO_MODE_ANALOG, GPIO_PUPD_NONE, pinB);
    }

    return OPRT_OK;

}

/**
 * @brief adc deinit
 *
 * @param[in] port_num: adc port number

 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_adc_deinit(TUYA_ADC_NUM_E port_num)
{
    // --- BEGIN: user implements ---
    adc_deinit();
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get adc width
 *
 * @param[in] port_num: adc port number

 *
 * @return adc width
 */
UINT8_T tkl_adc_width_get(TUYA_ADC_NUM_E port_num)
{
    // --- BEGIN: user implements ---
    return adc_env_info.width;
    // --- END: user implements ---
}

/**
 * @brief get adc reference voltage
 *
 * @param[in] port_num

 *
 * @return adc reference voltage(bat: mv)
 */
UINT32_T tkl_adc_ref_voltage_get(TUYA_ADC_NUM_E port_num)
{
    // --- BEGIN: user implements ---
    UINT32_T voltage;
    UINT16_T adc_value;

    adc_flag_clear(ADC_FLAG_EOC);
    /* ADC external trigger disable */
    adc_external_trigger_config(ADC_ROUTINE_CHANNEL, EXTERNAL_TRIGGER_DISABLE);
    /* ADC channel length config */
    adc_channel_length_config(ADC_ROUTINE_CHANNEL, 1U);
    /* ADC temperature sensor channel config */
    adc_routine_channel_config(0, ADC_CHANNEL_10, ADC_SAMPLETIME_479POINT5);

    adc_resolution_config(ADC_RESOLUTION_12B);

    /* ADC contineous function disable */
    adc_special_function_config(ADC_CONTINUOUS_MODE, DISABLE);
    /* ADC scan mode disable */
    adc_special_function_config(ADC_SCAN_MODE, DISABLE);

    adc_tempsensor_vrefint_enable();

    /* enable ADC interface */
    adc_enable();

    /* wait for ADC stability */
    sys_ms_sleep(1);

    /* ADC software trigger enable */
    adc_software_trigger_enable(ADC_ROUTINE_CHANNEL);

    /* delay a time in milliseconds */
    sys_ms_sleep(200);

    while(SET != adc_flag_get(ADC_STAT_EOC)){
    }
    adc_flag_clear(ADC_STAT_EOC);

    adc_value = adc_routine_data_read();

    adc_tempsensor_vrefint_disable();
    adc_disable();

    dbg_print(NOTICE, "tkl_adc_ref_voltage_get voltage %d\r\n", adc_value);

    /* value convert */
    voltage = (UINT32_T)(adc_value * ADC_VOL_MAX / 4096);

    return voltage;
    // --- END: user implements ---
}

/**
 * @brief adc get temperature
 *
 * @return temperature(bat: 'C)
 */
INT32_T tkl_adc_temperature_get(VOID_T)
{
    // --- BEGIN: user implements ---
    INT32_T temperature;
    UINT16_T adc_value;

    adc_flag_clear(ADC_FLAG_EOC);
    /* ADC external trigger disable */
    adc_external_trigger_config(ADC_ROUTINE_CHANNEL, EXTERNAL_TRIGGER_DISABLE);
    /* ADC channel length config */
    adc_channel_length_config(ADC_ROUTINE_CHANNEL, 1U);
    /* ADC temperature sensor channel config */
    adc_routine_channel_config(0, ADC_CHANNEL_9, ADC_SAMPLETIME_479POINT5);

    adc_resolution_config(ADC_RESOLUTION_12B);

    /* ADC contineous function disable */
    adc_special_function_config(ADC_CONTINUOUS_MODE, DISABLE);
    /* ADC scan mode disable */
    adc_special_function_config(ADC_SCAN_MODE, DISABLE);

    adc_tempsensor_vrefint_enable();

    /* enable ADC interface */
    adc_enable();

    /* wait for ADC stability */
    sys_ms_sleep(1);

    /* ADC software trigger enable */
    adc_software_trigger_enable(ADC_ROUTINE_CHANNEL);

    /* delay a time in milliseconds */
    sys_ms_sleep(200);

    while(SET != adc_flag_get(ADC_STAT_EOC)){
    }
    adc_flag_clear(ADC_STAT_EOC);

    adc_value = adc_routine_data_read();

    adc_tempsensor_vrefint_disable();
    adc_disable();

    dbg_print(NOTICE, "tkl_adc_temperature_get value %d \r\n", adc_value);
    /* value convert */
    temperature = (INT32_T)((1.43f - adc_value * 3.3f / 4096) * 1000 / 4.3f + 25);

    return temperature;
    // --- END: user implements ---
}

/**
 * @brief adc read
 *
 * @param[in] port_num: adc port number
 * @param[out] buff: points to the list of data read from the ADC register
 * @param[in] len:  buff len
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_adc_read_data(TUYA_ADC_NUM_E port_num, INT32_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    uint8_t i = 0;
    OPERATE_RET status = OPRT_OK;

    if (port_num > ADC_DEV_NUM) {
        return OPRT_INVALID_PARM;
    }

    if ((adc_env_info.ch_nums * adc_env_info.conv_cnt) > len) {
        dbg_print(NOTICE, "tkl_adc_read_data not enough data length\r\n");
        return OPRT_COM_ERROR;
    }

    adc_flag_clear(ADC_FLAG_EOC);
    if (adc_env_info.mode != TUYA_ADC_SCAN) {
        uint8_t buf_idx = 0;

        for (i = 0; i < ADC_DEV_CHNL_SUM; i++) {
            if (adc_env_info.ch_list & (1 << i)) {
                tkl_adc_read_single_channel(port_num, i, &buff[buf_idx * adc_env_info.conv_cnt]);
                buf_idx++;
            }
        }
    } else {
        uint16_t *p_adc_value = sys_malloc(sizeof(uint16_t) * adc_env_info.conv_cnt * adc_env_info.ch_nums);
        uint8_t rank = 0;

        if (p_adc_value == NULL) {
            return OPRT_MALLOC_FAILED;
        }

        tkl_adc_dma_config((adc_env_info.conv_cnt * adc_env_info.ch_nums), (void *)p_adc_value);

        /* ADC contineous function disable */
        adc_special_function_config(ADC_CONTINUOUS_MODE, ENABLE);
        /* ADC scan mode disable */
        adc_special_function_config(ADC_SCAN_MODE, ENABLE);
        /* ADC data alignment config */
        adc_data_alignment_config(ADC_DATAALIGN_RIGHT);
        /* ADC external trigger enable */
        adc_external_trigger_config(ADC_ROUTINE_CHANNEL, EXTERNAL_TRIGGER_DISABLE);
        /* ADC channel length config */
        adc_channel_length_config(ADC_ROUTINE_CHANNEL, adc_env_info.ch_nums);

        for (i = 0; i < ADC_DEV_CHNL_SUM; i++) {
            if (adc_env_info.ch_list & (1 << i)) {
                /* ADC inserted channel config */
                adc_routine_channel_config(rank, i, SAMPTX_SPT(i));
                rank++;
            }
        }

        /* enable ADC interface */
        adc_enable();
        /* wait for ADC stability */
        sys_ms_sleep(1);

        /* ADC DMA function enable */
        adc_dma_request_after_last_enable();
        adc_dma_mode_enable();
        /* enable ADC software trigger */
        adc_software_trigger_enable(ADC_ROUTINE_CHANNEL);

        sys_ms_sleep(100);

        while(1) {
            if (SET == dma_flag_get(DMA_CH0, DMA_FLAG_FTF)) {
                break;
            } else if (SET == dma_flag_get(DMA_CH0, DMA_FLAG_FEE)) {
                status = OPRT_OS_ADAPTER_ADC_READ_FAILED;
                break;
            }
        }


        for (i = 0; i < adc_env_info.conv_cnt * adc_env_info.ch_nums; i++) {
            buff[i] = p_adc_value[i];
        }

        adc_disable();
        adc_dma_mode_disable();

        sys_mfree(p_adc_value);
    }
    return status ;
    // --- END: user implements ---
}

/**
 * @brief read single channel
 *
 * @param[in] port_num: adc port number
 * @param[in] ch_id: channel id in one adc unit
 * @param[out] buff: convert result buffer
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 */
OPERATE_RET tkl_adc_read_single_channel(TUYA_ADC_NUM_E port_num, UINT8_T ch_id, INT32_T *data)
{
    // --- BEGIN: user implements ---
    uint8_t i;
    OPERATE_RET status = OPRT_OK;
    if (port_num > ADC_DEV_NUM || ch_id > ADC_DEV_CHNL_SUM) {
        return OPRT_INVALID_PARM;
    }

    adc_flag_clear(ADC_FLAG_EOC);
    adc_resolution_config(CTL0_DRES(adc_env_info.width));
    /* ADC scan mode disable */
    adc_special_function_config(ADC_SCAN_MODE, DISABLE);
    /* ADC external trigger enable */
    adc_external_trigger_config(ADC_ROUTINE_CHANNEL, EXTERNAL_TRIGGER_DISABLE);
    /* ADC channel length config */
    adc_channel_length_config(ADC_ROUTINE_CHANNEL, 1U);

    if (adc_env_info.mode == TUYA_ADC_SINGLE) {
        adc_discontinuous_mode_config(ADC_CHANNEL_DISCON_DISABLE, 0);
        /* ADC contineous function disable */
        adc_special_function_config(ADC_CONTINUOUS_MODE, DISABLE);
        /* ADC regular channel config */
        adc_routine_channel_config(0U, ch_id, SAMPTX_SPT(adc_env_info.adc_samp));

        /* enable ADC interface */
        adc_enable();
        /* wait for ADC stability */
        sys_ms_sleep(1);

        for (i = 0; i < adc_env_info.conv_cnt; i++) {
            data[i] = tkl_adc_channel_sample(ch_id);
        }

        adc_disable();
    } else {
        uint16_t *p_adc_value = sys_malloc(sizeof(uint16_t) * adc_env_info.conv_cnt);

        if (p_adc_value == NULL) {
            return OPRT_MALLOC_FAILED;
        }

        /* ADC contineous function enable */
        adc_special_function_config(ADC_CONTINUOUS_MODE, ENABLE);
        /* ADC inserted channel config */
        adc_routine_channel_config(0U, ch_id, SAMPTX_SPT(adc_env_info.adc_samp));

        tkl_adc_dma_config(adc_env_info.conv_cnt, (void *)p_adc_value);

        /* enable ADC interface */
        adc_enable();
        /* wait for ADC stability */
        sys_ms_sleep(1);

        /* ADC DMA function enable */
        adc_dma_request_after_last_enable();
        adc_dma_mode_enable();
        /* enable ADC software trigger */
        adc_software_trigger_enable(ADC_ROUTINE_CHANNEL);

        sys_ms_sleep(200);

        while(1) {
            if (SET == dma_flag_get(DMA_CH0, DMA_FLAG_FTF)) {
                break;
            } else if (SET == dma_flag_get(DMA_CH0, DMA_FLAG_FEE)) {
                status = OPRT_OS_ADAPTER_ADC_READ_FAILED;
                break;
            }
        }

        for (i = 0; i < adc_env_info.conv_cnt; i++) {
            data[i] = p_adc_value[i];
        }

        adc_disable();
        adc_dma_mode_disable();

        sys_mfree(p_adc_value);
    }

    return status;
    // --- END: user implements ---
}

/**
 * @brief read voltage
 *
 * @param[in] port_num: adc port number
 * @param[out] buff: points to the list of calculate voltage,bat : mv
 * @param[in] len:  buff len
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 */

OPERATE_RET tkl_adc_read_voltage(TUYA_ADC_NUM_E port_num, INT32_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
