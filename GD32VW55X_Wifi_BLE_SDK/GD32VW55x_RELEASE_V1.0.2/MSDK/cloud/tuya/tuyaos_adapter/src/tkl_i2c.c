/**
 * @file tkl_i2c.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "gd32vw55x.h"
#include "tkl_i2c.h"
#include "gd32vw55x_i2c.h"
#include "gd32vw55x_it.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT

UINT8_T addr_width = 0;

typedef struct i2c_irq_cb_item
{
    UINT32_T i2c_port;
    TUYA_I2C_IRQ_CB callback;
} i2c_irq_cb_item_t;

struct i2c_irq_driver
{
    i2c_irq_cb_item_t i2c_irq_cbs[TUYA_I2C_NUM_MAX];
};

static struct i2c_irq_driver i2c_irq_mgr = {0};

static UINT32_T i2c_port_transfer(TUYA_I2C_NUM_E port)
{
    UINT32_T i2c_port = 0;

    switch (port) {
    case TUYA_I2C_NUM_0:
        i2c_port = I2C0;
    case TUYA_I2C_NUM_1:
        i2c_port = I2C1;
    default:
        break;
    }
    return i2c_port;
}

static TUYA_IIC_IRQ_EVT_E i2c_irq_source_get(UINT32_T i2c_port)
{
    TUYA_IIC_IRQ_EVT_E event = TUYA_IIC_EVENT_TRANSFER_DONE;

    /* transmit */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_TI)) {
        event = TUYA_IIC_EVENT_SLAVE_RECEIVE;
    }

    /* I2C_RDATA is not empty during receiving */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_RBNE)) {
        event = TUYA_IIC_EVENT_SLAVE_TRANSMIT;
    }

    /* not acknowledge */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_NACK)) {
        event = TUYA_IIC_EVENT_ADDRESS_NACK;
    }

    /* transfer complete in master mode */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_TC)) {
        event = TUYA_IIC_EVENT_TRANSFER_DONE;
    }

    /* bus error */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_BERR)) {
        event = TUYA_IIC_EVENT_BUS_ERROR;
    }

    /* arbitration lost */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_LOSTARB)) {
        event = TUYA_IIC_EVENT_ARBITRATION_LOST;
    }

    /* timeout error */
    if(i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_TIMEOUT)) {
        event = TUYA_IIC_EVENT_BUS_CLEAR;
    }
    return event;
#if 0
    /* address received matches in slave mode */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_ADDSEND)) {
    }
    /* stop condition detected in slave mode */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_STPDET)) {
    }
    /* transfer complete reload */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_TCR)) {
    }
    /* over-run or under-run when SCL stretch is disabled */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_OUERR)) {
    }
    /* PEC error */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_PECERR)) {
    }
    /* SMBus alert */
    if (i2c_interrupt_flag_get(I2C1, I2C_INT_FLAG_SMBALT)) {
    }
#endif
}

static void i2c_irq_flag_clear(UINT32_T i2c_port, TUYA_IIC_IRQ_EVT_E event)
{
    switch (event) {
    case TUYA_IIC_EVENT_SLAVE_RECEIVE:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_TI);
        break;
    case TUYA_IIC_EVENT_SLAVE_TRANSMIT:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_RBNE);
        break;
    case TUYA_IIC_EVENT_ADDRESS_NACK:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_NACK);
        break;
    case TUYA_IIC_EVENT_TRANSFER_DONE:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_TC);
        break;
    case TUYA_IIC_EVENT_BUS_ERROR:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_BERR);
        break;
    case TUYA_IIC_EVENT_ARBITRATION_LOST:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_LOSTARB);
        break;
    case TUYA_IIC_EVENT_BUS_CLEAR:
        i2c_interrupt_flag_clear(i2c_port, I2C_INT_FLAG_TIMEOUT);
        break;
    default:
        break;
    }
}

BOOL_T i2c_irq_callback_register(UINT32_T i2c_port, TUYA_I2C_IRQ_CB callback)
{
    UINT8_T i;

    for (i = 0; i < TUYA_I2C_NUM_MAX; i++) {
        // uart port already register callback
        if (i2c_irq_mgr.i2c_irq_cbs[i].i2c_port == i2c_port || \
            i2c_irq_mgr.i2c_irq_cbs[i].i2c_port == 0) {
            i2c_irq_mgr.i2c_irq_cbs[i].callback = callback;
            i2c_irq_mgr.i2c_irq_cbs[i].i2c_port = i2c_port;
            return TRUE;
        }
    }

    return FALSE;
}

void i2c_irq_hdl(UINT32_T i2c_port)
{
    uint8_t i;
    TUYA_IIC_IRQ_EVT_E irq_event;

    for (i = 0; i < TUYA_I2C_NUM_MAX; i++) {
        if (i2c_irq_mgr.i2c_irq_cbs[i].i2c_port == i2c_port) {
            irq_event = i2c_irq_source_get(i2c_port);
            i2c_irq_mgr.i2c_irq_cbs[i].callback(i2c_port, irq_event);
            i2c_irq_flag_clear(i2c_port, irq_event);
            return;
        }
    }
}

static void i2c0_gpio_config(void)
{
    /* connect PA8 to I2C1_SDA */
    gpio_af_set(GPIOA, GPIO_AF_4, GPIO_PIN_3); // PA3 I2C0_SDA
    /* connect PB15 to I2C1_SCL */
    gpio_af_set(GPIOA, GPIO_AF_4, GPIO_PIN_2); // PA2 I2C0_SCL
    /* configure GPIO pins of I2C1 */
    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_3);
    gpio_output_options_set(GPIOA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ, GPIO_PIN_3);
    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_2);
    gpio_output_options_set(GPIOA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ, GPIO_PIN_2);
}

static void i2c1_gpio_config(void)
{
    /* connect PA8 to I2C1_SDA */
    gpio_af_set(GPIOA, GPIO_AF_6, GPIO_PIN_8); // PA8 I2C1_SDA
    /* connect PB15 to I2C1_SCL */
    gpio_af_set(GPIOA, GPIO_AF_6, GPIO_PIN_15); // PA15 I2C1_SCL
    /* configure GPIO pins of I2C1 */
    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_8);
    gpio_output_options_set(GPIOA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ, GPIO_PIN_8);
    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLUP, GPIO_PIN_15);
    gpio_output_options_set(GPIOA, GPIO_OTYPE_OD, GPIO_OSPEED_25MHZ, GPIO_PIN_15);
}

/**
 * @brief i2c init
 *
 * @param[in] port: i2c port
 * @param[in] cfg: i2c config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_init(TUYA_I2C_NUM_E port, CONST TUYA_IIC_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);

    /* enable GPIOA clock */
    rcu_periph_clock_enable(RCU_GPIOA);
    /* enable I2C1 clock */
    rcu_periph_clock_enable(RCU_I2C1);

    if (i2c_port == I2C0) {
        i2c0_gpio_config();
    } else if (i2c_port == I2C1) {
        i2c1_gpio_config();
    } else {
        return OPRT_OS_ADAPTER_I2C_INVALID_PARM;
    }

    if (cfg->speed == TUYA_IIC_BUS_SPEED_100K) {
        i2c_timing_config(i2c_port, 1, 0xA, 0);
        i2c_master_clock_config(i2c_port, 0x0, 0xE9);
    } else if (cfg->speed == TUYA_IIC_BUS_SPEED_400K) {
        i2c_timing_config(i2c_port, 0, 0x8, 0);
        i2c_master_clock_config(i2c_port, 0x30, 0x91);
    } else if (cfg->speed == TUYA_IIC_BUS_SPEED_1M) {
        i2c_timing_config(i2c_port, 0, 0x4, 0);
        i2c_master_clock_config(i2c_port, 0x14, 0x35);
    } else if (cfg->speed == TUYA_IIC_BUS_SPEED_3_4M) {
        return OPRT_OS_ADAPTER_I2C_INVALID_PARM;
    }

    if (cfg->addr_width == TUYA_IIC_ADDRESS_7BIT) {
        addr_width = 7;
    } else {
        addr_width = 10;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c deinit
 *
 * @param[in] port: i2c port
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_deinit(TUYA_I2C_NUM_E port)
{
    // --- BEGIN: user implements ---
    i2c_deinit(i2c_port_transfer(port));
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c irq init
 * NOTE: call this API will not enable interrupt
 *
 * @param[in] port: i2c port, id index starts at 0
 * @param[in] cb:  i2c irq cb
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_irq_init(TUYA_I2C_NUM_E port, TUYA_I2C_IRQ_CB cb)
{
    // --- BEGIN: user implements ---
    if (i2c_irq_callback_register(i2c_port_transfer(port), cb))
        return OPRT_OK;

     return OPRT_OS_ADAPTER_I2C_IRQ_INIT_FAILED;
    // --- END: user implements ---
}

/**
 * @brief i2c irq enable
 *
 * @param[in] port: i2c port id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_irq_enable(TUYA_I2C_NUM_E port)
{
    // --- BEGIN: user implements ---
    i2c_interrupt_enable(i2c_port_transfer(port), I2C_INT_ERR | I2C_INT_TC | \
                                              I2C_INT_STPDET | I2C_INT_NACK | \
                                              I2C_INT_ADDM | I2C_INT_RBNE | \
                                              I2C_INT_TI);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c irq disable
 *
 * @param[in] port: i2c port id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_irq_disable(TUYA_I2C_NUM_E port)
{
    // --- BEGIN: user implements ---
    i2c_interrupt_disable(i2c_port_transfer(port), I2C_INT_ERR | I2C_INT_TC | \
                                            I2C_INT_STPDET | I2C_INT_NACK | \
                                            I2C_INT_ADDM | I2C_INT_RBNE | \
                                            I2C_INT_TI);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c master send
 *
 * @param[in] port: i2c port
 * @param[in] dev_addr: iic addrress of slave device.
 * @param[in] data: i2c data to send
 * @param[in] size: Number of data items to send
 * @param[in] xfer_pending: xfer_pending: TRUE : not send stop condition, FALSE : send stop condition.
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_master_send(TUYA_I2C_NUM_E port, UINT16_T dev_addr, CONST VOID_T *data, UINT32_T size, BOOL_T xfer_pending)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);
    UINT8_T i;
    UINT32_T *data_transmit = (UINT32_T *)data;


    if (addr_width == 10) {
        /* enable 10-bit addressing mode in master mode */
        i2c_address10_enable(i2c_port);
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_10BITS);
    } else if (addr_width == 7) {
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_7BITS);
    }

    i2c_transfer_byte_number_config(i2c_port, size);
    /* enable I2C */
    i2c_enable(i2c_port);

    /* wait until I2C bus is idle */
    while(i2c_flag_get(i2c_port, I2C_FLAG_I2CBSY));
    /* send a start condition to I2C bus */
    i2c_start_on_bus(i2c_port);
    /* wait until the transmit data buffer is empty */
    I2C_STAT(i2c_port) |= I2C_STAT_TBE;
    while(!i2c_flag_get(i2c_port, I2C_FLAG_TBE));

    for (i = 0; i < size; i++) {
        /* data transmission */
        i2c_data_transmit(i2c_port, data_transmit[i]);
        /* wait until the TI bit is set */
        while(!i2c_flag_get(i2c_port, I2C_FLAG_TI));
    }

    /* wait for transfer complete flag */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_TC));
    /* send a stop condition to I2C bus */
    i2c_stop_on_bus(i2c_port);
    /* wait until stop condition generate */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_STPDET));
    /* clear the STPDET bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_STPDET);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c master recv
 *
 * @param[in] port: i2c port
 * @param[in] dev_addr: iic addrress of slave device.
 * @param[in] data: i2c buf to recv
 * @param[in] size: Number of data items to receive
 * @param[in] xfer_pending: TRUE : not send stop condition, FALSE : send stop condition.
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_master_receive(TUYA_I2C_NUM_E port, UINT16_T dev_addr, VOID *data, UINT32_T size, BOOL_T xfer_pending)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);
    UINT8_T i;
    UINT32_T *data_receive = (UINT32_T *)data;

    if (addr_width == 10) {
        /* enable 10-bit addressing mode in master mode */
        i2c_address10_enable(i2c_port);
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_10BITS);
    } else if (addr_width == 7) {
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_7BITS);
    }

    /* configure slave address */
    i2c_master_addressing(i2c_port, dev_addr, I2C_MASTER_RECEIVE);
    i2c_transfer_byte_number_config(i2c_port, size);
    /* enable I2C */
    i2c_enable(i2c_port);

    /* wait until I2C bus is idle */
    while(i2c_flag_get(i2c_port, I2C_FLAG_I2CBSY));
    /* send a start condition to I2C bus */
    i2c_start_on_bus(i2c_port);

    for (i = 0; i < size; i++) {
        /* wait until the RBNE bit is set */
        while(!i2c_flag_get(i2c_port, I2C_FLAG_RBNE));
        /* read a data from I2C_DATA */
        data_receive[i] = i2c_data_receive(i2c_port);
    }
    while(!i2c_flag_get(i2c_port, I2C_FLAG_TC));
    /* send a stop condition to I2C bus */
    i2c_stop_on_bus(i2c_port);
    /* wait until stop condition generate */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_STPDET));
    /* clear the STPDET bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_STPDET);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c slave
 *
 * @param[in] port: i2c port
 * @param[in] dev_addr: slave device addr
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_set_slave_addr(TUYA_I2C_NUM_E port, UINT16_T dev_addr)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);

    if (addr_width == 10) {
        /* enable 10-bit addressing mode in master mode */
        i2c_address10_enable(i2c_port);
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_10BITS);
    } else if (addr_width == 7) {
        /* configure I2C address */
        i2c_address_config(i2c_port, dev_addr, I2C_ADDFORMAT_7BITS);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c slave send
 *
 * @param[in] port: i2c port
 * @param[in] data: i2c buf to send
 * @param[in] size: Number of data items to send
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

OPERATE_RET tkl_i2c_slave_send(TUYA_I2C_NUM_E port, CONST VOID *data, UINT32_T size)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);
    UINT8_T i;
    UINT32_T *data_transmit = (UINT32_T *)data;

    /* enable I2C1 */
    i2c_enable(i2c_port);

    /* wait until ADDSEND bit is set */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_ADDSEND));
    /* clear ADDSEND bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_ADDSEND);
    if (addr_width == 10) {
        /* wait until ADDSEND bit is set */
        while(!i2c_flag_get(i2c_port, I2C_FLAG_ADDSEND));
        i2c_flag_clear(i2c_port, I2C_FLAG_ADDSEND);
    }
    I2C_STAT(i2c_port) |= I2C_STAT_TBE;
    /* wait until the transmission data register is empty */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_TBE));

    for (i = 0; i < size; i++) {
        /* send a data byte */
        i2c_data_transmit(i2c_port, data_transmit[i]);
        /* wait until the transmission data register is empty */
        while(!i2c_flag_get(i2c_port, I2C_FLAG_TI));
    }
    /* wait until stop condition generate */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_STPDET));
    /* clear the STPDET bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_STPDET);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief IIC slave receive, Start receiving data as IIC Slave.
 *
 * @param[in] port: i2c port
 * @param[in] data: Pointer to buffer for data to receive from IIC Master
 * @param[in] size: Number of data items to receive
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

OPERATE_RET tkl_i2c_slave_receive(TUYA_I2C_NUM_E port, VOID *data, UINT32_T size)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);
    UINT8_T i;
    UINT32_T *data_receive = (UINT32_T *)data;

    /* enable I2C1 */
    i2c_enable(i2c_port);
    /* wait until ADDSEND bit is set */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_ADDSEND));
    /* clear ADDSEND bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_ADDSEND);
    for (i = 0; i < size; i++) {
        /* wait until the RBNE bit is set */
        while(!i2c_flag_get(i2c_port, I2C_FLAG_RBNE));
        /* read a data byte from I2C_RDATA */
        data_receive[i] = i2c_data_receive(i2c_port);
    }
    /* wait until the STPDET bit is set */
    while(!i2c_flag_get(i2c_port, I2C_FLAG_STPDET));
    /* clear the STPDET bit */
    i2c_flag_clear(i2c_port, I2C_FLAG_STPDET);



    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief IIC get status.
 *
 * @param[in] port: i2c port
 * @param[out]  TUYA_IIC_STATUS_T
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_get_status(TUYA_I2C_NUM_E port, TUYA_IIC_STATUS_T *status)
{
    // --- BEGIN: user implements ---
    UINT32_T i2c_port = i2c_port_transfer(port);

    if (!status)
        return OPRT_COM_ERROR;
    if (!i2c_flag_get(i2c_port, I2C_FLAG_TR))
        status->direction = 1;
    if (i2c_flag_get(i2c_port, I2C_FLAG_I2CBSY))
        status->busy = 1;
    if (i2c_flag_get(i2c_port, I2C_FLAG_LOSTARB))
        status->arbitration_lost = 1;
    if (i2c_flag_get(i2c_port, I2C_FLAG_BERR))
        status->bus_error = 1;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c's reset
 *
 * @param[in] port: i2c port number
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET  tkl_i2c_reset(TUYA_I2C_NUM_E port)
{
    // --- BEGIN: user implements ---
    tkl_i2c_deinit(port);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief i2c transferred data count.
 *
 * @param[in] port: i2c port id, id index starts at 0
 *
 * @return >=0,number of currently transferred data items. <0,err.
 * tkl_i2c_master_send:number of data bytes transmitted and acknowledged
 * tkl_i2c_master_receive:number of data bytes received
 * tkl_i2c_slave_send:number of data bytes transmitted
 * tkl_i2c_slave_receive:number of data bytes received and acknowledged
 */
INT32_T tkl_i2c_get_data_count(TUYA_I2C_NUM_E port)
{
    // --- BEGIN: user implements ---
    return 0;
    // --- END: user implements ---
}

/**
 * @brief i2c ioctl
 *
 * @param[in]       cmd     user def
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_i2c_ioctl(TUYA_I2C_NUM_E port, UINT32_T cmd,  VOID *args)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
