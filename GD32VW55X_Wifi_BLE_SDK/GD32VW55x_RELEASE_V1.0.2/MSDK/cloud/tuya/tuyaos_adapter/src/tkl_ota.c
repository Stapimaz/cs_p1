/**
 * @file tkl_ota.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "config_gdm32.h"
#include "tkl_ota.h"
#include "tkl_flash.h"
#include "tuya_error_code.h"
#include "rom_export.h"
#include "raw_flash_api.h"
#include "tkl_output.h"
#include "tkl_memory.h"
#include "tkl_system.h"

#ifdef TUYAOS_SUPPORT

#define IMAGE_WRITE_SIZE 1024 // 512
#define ERASE_SIZE       0x8000 // 32K

typedef struct {
    UINT32_T start_addr;
    UINT32_T erase_start_addr;
    UINT32_T recv_data_cnt;
    UINT32_T flash_offset;
    UINT32_T runing_image_idx;
    UINT32_T image_max_size;
}UG_PROC_S;

static UG_PROC_S *ug_proc = NULL;

// --- END: user defines and implements ---

/**
* @brief get ota ability
*
* @param[out] image_size:  max image size
* @param[out] type:   TUYA_OTA_TYPE_E, full package or compress package use TUYA_OTA_FULL, difference ota use TUYA_OTA_DIFF
* @note This API is used for get chip ota ability
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_ota_get_ability(UINT_T *image_size, TUYA_OTA_TYPE_E *type)
{
    // --- BEGIN: user implements ---
    UINT8_T running_idx = 0;
    INT32_T res = 0;

    res = rom_sys_status_get(SYS_RUNNING_IMG, LEN_SYS_RUNNING_IMG, &running_idx);
    if (res < 0) {
        tkl_log_output("Get sys running idx failed! (res = %d)\r\n", res);
        return OPRT_COM_ERROR;
    }

    if (running_idx == IMAGE_0) {
        *image_size = RE_IMG_1_END - RE_IMG_1_OFFSET;
    } else if (running_idx == IMAGE_1) {
        *image_size = RE_IMG_1_OFFSET - RE_IMG_0_OFFSET;
    } else {
        return OPRT_COM_ERROR;
    }

    *type = TUYA_OTA_FULL;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief ota start notify
*
* @param[in] image_size:  image size
* @param[in] type:        ota type
* @param[in] path:        ota path
*
* @note This API is used for ota start notify
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_ota_start_notify(UINT_T image_size, TUYA_OTA_TYPE_E type, TUYA_OTA_PATH_E path)
{
    // --- BEGIN: user implements ---
    UINT8_T running_idx = 0;
    INT32_T res = 0;

    if (image_size == 0) {
        return OPRT_OS_ADAPTER_OTA_PKT_SIZE_FAILED;
    }

    if (ug_proc == NULL) {
        ug_proc = (UG_PROC_S *)tkl_system_malloc(sizeof(UG_PROC_S));
        if (NULL == ug_proc) {
            return OPRT_MALLOC_FAILED;
        }
    }

    memset(ug_proc, 0, sizeof(UG_PROC_S));

    res = rom_sys_status_get(SYS_RUNNING_IMG, LEN_SYS_RUNNING_IMG, &running_idx);
    if (res < 0) {
        return OPRT_OS_ADAPTER_OTA_START_INFORM_FAILED;
    }

    if (running_idx == IMAGE_0) {
        ug_proc->runing_image_idx = IMAGE_0;
        ug_proc->start_addr = RE_IMG_1_OFFSET;
        ug_proc->image_max_size = RE_IMG_1_END - RE_IMG_1_OFFSET;
    } else if (running_idx == IMAGE_1) {
        ug_proc->runing_image_idx = IMAGE_1;
        ug_proc->start_addr = RE_IMG_0_OFFSET;
        ug_proc->image_max_size = RE_IMG_1_OFFSET - RE_IMG_0_OFFSET;
    } else {
        return OPRT_OS_ADAPTER_OTA_START_INFORM_FAILED;
    }
    ug_proc->erase_start_addr = ug_proc->start_addr;
    ug_proc->flash_offset = 0;

    if (image_size > ug_proc->image_max_size) {
        return OPRT_OS_ADAPTER_OTA_PKT_SIZE_FAILED;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief ota data process
*
* @param[in] pack:       point to ota pack
* @param[in] remain_len: ota pack remain len
*
* @note This API is used for ota data process
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_ota_data_process(TUYA_OTA_DATA_T *pack, UINT_T* remain_len)
{
    // --- BEGIN: user implements ---
    INT32_T ret = 0;
    UINT32_T remain_length = 0;

    *remain_len = pack->len;
    if ((pack->len < IMAGE_WRITE_SIZE) && (ug_proc->recv_data_cnt <= (pack->total_len - IMAGE_WRITE_SIZE))) {
        return OPRT_OK;
    }

    remain_length = pack->len;

    // erase flash
    while ((ug_proc->recv_data_cnt + ug_proc->start_addr + pack->len) > ug_proc->erase_start_addr) {
        ret = raw_flash_erase(ug_proc->erase_start_addr, ERASE_SIZE);
        if (ret != 0) {
            tkl_log_output("Erase flash sector failed\r\n");
            return OPRT_OS_ADAPTER_OTA_PROCESS_FAILED;
        } else {
            ug_proc->erase_start_addr += ERASE_SIZE; // erase a sector
        }
    }

    // write flash
    while (remain_length >= IMAGE_WRITE_SIZE) {
        if (tkl_flash_write((ug_proc->start_addr + ug_proc->flash_offset),
                            &pack->data[pack->len - remain_length], IMAGE_WRITE_SIZE)) {
            tkl_log_output("Write flash sector failed\r\n");
            return OPRT_OS_ADAPTER_OTA_PROCESS_FAILED;
        }
        ug_proc->flash_offset += IMAGE_WRITE_SIZE;
        ug_proc->recv_data_cnt += IMAGE_WRITE_SIZE;
        remain_length -= IMAGE_WRITE_SIZE;
        *remain_len = remain_length;
    }

    // write last remain iamge
    if ((ug_proc->recv_data_cnt > (pack->total_len - IMAGE_WRITE_SIZE))
        && (remain_length >= (pack->total_len - ug_proc->recv_data_cnt))) {
        if (tkl_flash_write((ug_proc->start_addr + ug_proc->flash_offset),
                            &pack->data[pack->len - remain_length], remain_length)) {
            tkl_log_output("Write flash sector failed\r\n");
            return OPRT_OS_ADAPTER_OTA_PROCESS_FAILED;
        }
        ug_proc->flash_offset += remain_length;
        ug_proc->recv_data_cnt += remain_length;
        remain_length = 0;
        *remain_len = 0;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief ota end notify
*
* @param[in] reset:  ota reset
*
* @note This API is used for ota end notify
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_ota_end_notify(BOOL_T reset)
{
    // --- BEGIN: user implements ---
    INT_T res = 0;

    /* Set image status */
    res = rom_sys_set_img_flag(ug_proc->runing_image_idx, (IMG_FLAG_IA_MASK | IMG_FLAG_NEWER_MASK), (IMG_FLAG_IA_OK | IMG_FLAG_OLDER));
    res |= rom_sys_set_img_flag(!ug_proc->runing_image_idx, (IMG_FLAG_IA_MASK | IMG_FLAG_VERIFY_MASK | IMG_FLAG_NEWER_MASK), 0);
    res |= rom_sys_set_img_flag(!ug_proc->runing_image_idx, IMG_FLAG_NEWER_MASK, IMG_FLAG_NEWER);
    if (res != 0) {
        tkl_log_output("Set sys image status failed! (res = %d)\r\n", res);
        return OPRT_OS_ADAPTER_OTA_END_INFORM_FAILED;
    }

    if (reset == TRUE) {
        tkl_system_reset();
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
* @brief get old firmware info
*
* @param[out] image_size:  max image size
* @param[out] type:        ota type
*
* @note This API is used for old firmware info, and only used in resumes transmission at break-points
* @note Only use for ble sub device
*
* @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
*/
OPERATE_RET tkl_ota_get_old_firmware_info(TUYA_OTA_FIRMWARE_INFO_T **info)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
