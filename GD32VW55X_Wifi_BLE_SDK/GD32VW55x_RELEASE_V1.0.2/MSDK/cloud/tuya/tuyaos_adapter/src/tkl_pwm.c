/**
 * @file tkl_pwm.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "gd32vw55x_rcu.h"
#include "gd32vw55x_eclic.h"
#include "gd32vw55x_timer.h"
#include "gd32vw55x_gpio.h"
#include "wrapper_os.h"
#include "tkl_pwm.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT

extern uint32_t SystemCoreClock; // default 160000000

typedef struct pwm_pin_map {
    UINT32_T gpio_group;
    UINT32_T pin_num;
    UINT32_T af_num;
} pwm_pin_map_t;

typedef struct pwm_dev_config {
    UINT32_T timer;
    UINT16_T channel;
    pwm_pin_map_t pin_info;
    TUYA_PWM_BASE_CFG_T cfg;
} pwm_dev_config_t;

static pwm_dev_config_t pwm_dev[TUYA_PWM_NUM_MAX] = {
    {TIMER0,  TIMER_CH_0, { GPIOA, GPIO_PIN_8,  GPIO_AF_1 }, {0}}, // TIMER0 ch0
    // TIMER1 & TIMER2 used as normal timer
    // {TIMER1,  TIMER_CH_0, { GPIOB, GPIO_PIN_4,  GPIO_AF_1 }, {0}}, // TIMER1 CH0
    // {TIMER2,  TIMER_CH_0, { GPIOB, GPIO_PIN_15, GPIO_AF_2 }, {0}}, // TIMER2 ch0
    {TIMER15, TIMER_CH_0, { GPIOB, GPIO_PIN_13, GPIO_AF_8 }, {0}}, // TIMER15 ch0, has only one channel
    {TIMER16, TIMER_CH_0, { GPIOA, GPIO_PIN_10, GPIO_AF_7 }, {0}}, // TIMER16 ch0, has only one channel
};

static void pwm_gpio_config(TUYA_PWM_NUM_E ch_id)
{
    if (ch_id >= TUYA_PWM_NUM_MAX)
        return;

    pwm_pin_map_t *pin_info_t = &pwm_dev[ch_id].pin_info;

    gpio_mode_set(pin_info_t->gpio_group, GPIO_MODE_AF, GPIO_PUPD_NONE, pin_info_t->pin_num);
    gpio_output_options_set(pin_info_t->gpio_group, GPIO_OTYPE_PP, GPIO_OSPEED_MAX, pin_info_t->pin_num);
    gpio_af_set(pin_info_t->gpio_group, pin_info_t->af_num, pin_info_t->pin_num);

    return;
}

static void pwm_dev_rcu_enable(TUYA_PWM_NUM_E ch_id)
{
    pwm_dev_config_t *pwm_device = NULL;

    if (ch_id >= TUYA_PWM_NUM_MAX)
        return;

    pwm_device = &pwm_dev[ch_id];

    switch (pwm_device->pin_info.gpio_group) {
    case GPIOA:
        rcu_periph_clock_enable(RCU_GPIOA);
        break;
    case GPIOB:
        rcu_periph_clock_enable(RCU_GPIOB);
        break;
    case GPIOC:
        rcu_periph_clock_enable(RCU_GPIOC);
        break;
    default:
        break;
    }

    rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL2);

    switch (pwm_device->timer) {
    case TIMER0:
        rcu_periph_clock_enable(RCU_TIMER0);
        break;
    // case TIMER1:
    //     rcu_periph_clock_enable(RCU_TIMER1);
    //     break;
    // case TIMER2:
    //     rcu_periph_clock_enable(RCU_TIMER2);
    //     break;
    case TIMER15:
        rcu_periph_clock_enable(RCU_TIMER15);
        break;
    case TIMER16:
        rcu_periph_clock_enable(RCU_TIMER16);
        break;
    default:
        break;
    }
    return;
}

/**
 * @brief pwm init
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] cfg: pwm config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_init(TUYA_PWM_NUM_E ch_id, CONST TUYA_PWM_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    if ((ch_id >= TUYA_PWM_NUM_MAX) || !cfg)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    /* frequency, cycle and duty check */
    if ((cfg->frequency < 2500) || (cfg->frequency  > SystemCoreClock) \
        || (cfg->cycle > 0xFFFF) || (cfg->duty > 0xFFFF))
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    sys_memcpy(&pwm_dev[ch_id].cfg, cfg, sizeof(TUYA_PWM_BASE_CFG_T));

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm deinit
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_deinit(TUYA_PWM_NUM_E ch_id)
{
    // --- BEGIN: user implements ---
    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    timer_deinit(pwm_dev[ch_id].timer);
    sys_memset(&pwm_dev[ch_id].cfg, 0, sizeof(TUYA_PWM_BASE_CFG_T));

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm start
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_start(TUYA_PWM_NUM_E ch_id)
{
    // --- BEGIN: user implements ---
    timer_parameter_struct timer_initpara = {0};
    timer_oc_parameter_struct timer_ocintpara = {0};
    pwm_dev_config_t *pwm_config = NULL;
    TUYA_PWM_BASE_CFG_T *cfg = NULL;

    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    cfg = &pwm_dev[ch_id].cfg;
    pwm_config = &pwm_dev[ch_id];

    /* GPIO config */
    pwm_dev_rcu_enable(ch_id);
    pwm_gpio_config(ch_id);

    timer_deinit(pwm_config->timer);

    /* TIMERx configuration */
    timer_initpara.prescaler = (SystemCoreClock / cfg->frequency) - 1;
    if (cfg->cycle == 0) {
        timer_initpara.period = cfg->duty * 2 - 1;
    } else {
        timer_initpara.period = cfg->cycle - 1;
    }

    if (cfg->count_mode == TUYA_PWM_CNT_UP) {
        timer_initpara.alignedmode = TIMER_COUNTER_EDGE;
        timer_initpara.counterdirection = TIMER_COUNTER_UP;
    } else if (cfg->count_mode == TUYA_PWM_CNT_UP_AND_DOWN) {
        timer_initpara.alignedmode = TIMER_COUNTER_CENTER_BOTH;
    } else {
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;
    }
    timer_initpara.clockdivision = TIMER_CKDIV_DIV1;
    timer_initpara.repetitioncounter = 0;
    timer_init(pwm_config->timer, &timer_initpara);

    /* timer's channel configuration in PWM mode */
    timer_ocintpara.outputstate  = TIMER_CCX_ENABLE;
    timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;
    if (cfg->polarity == TUYA_PWM_NEGATIVE) {
        timer_ocintpara.ocpolarity   = TIMER_OC_POLARITY_LOW;
        timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;
        timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_HIGH;
        timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_HIGH;
    } else if (cfg->polarity == TUYA_PWM_POSITIVE) {
        timer_ocintpara.ocpolarity   = TIMER_OC_POLARITY_HIGH;
        timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;
        timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_LOW;
        timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    }

    timer_channel_output_config(pwm_config->timer, pwm_config->channel, &timer_ocintpara);

    /* timer channel configuration in PWM mode0 */
    timer_channel_output_pulse_value_config(pwm_config->timer, pwm_config->channel, cfg->duty - 1);
    timer_channel_output_mode_config(pwm_config->timer, pwm_config->channel, TIMER_OC_MODE_PWM0);
    timer_channel_output_shadow_config(pwm_config->timer, pwm_config->channel, TIMER_OC_SHADOW_DISABLE);

    // if (pwm_config->timer != TIMER1 && pwm_config->timer != TIMER2)
    timer_primary_output_config(pwm_config->timer, ENABLE);

    /* auto-reload preload enable */
    timer_auto_reload_shadow_enable(pwm_config->timer);
    timer_enable(pwm_config->timer);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm stop
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_stop(TUYA_PWM_NUM_E ch_id)
{
    // --- BEGIN: user implements ---
    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    timer_auto_reload_shadow_disable(pwm_dev[ch_id].timer);
    timer_disable(pwm_dev[ch_id].timer);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief multiple pwm channel start
 *
 * @param[in] ch_id: pwm channal id list
 * @param[in] num  : num of pwm channal to start
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_multichannel_start(TUYA_PWM_NUM_E *ch_id, UINT8_T num)
{
    // --- BEGIN: user implements ---
    UINT8_T i = 0;

    for (i = 0; i < num; i++) {
        tkl_pwm_start(ch_id[i]);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief multiple pwm channel stop
 *
 * @param[in] ch_id: pwm channal id list
 * @param[in] num  : num of pwm channal to stop
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_multichannel_stop(TUYA_PWM_NUM_E *ch_id, UINT8_T num)
{
    // --- BEGIN: user implements ---
    UINT8_T i = 0;

    for (i = 0; i < num; i++) {
        tkl_pwm_stop(ch_id[i]);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm duty set
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] duty:  pwm duty cycle
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_duty_set(TUYA_PWM_NUM_E ch_id, UINT32_T duty)
{
    // --- BEGIN: user implements ---
    pwm_dev_config_t *pwm_config = NULL;

    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    if (duty > 0xFFFF)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    /* stop first */
    tkl_pwm_stop(ch_id);
    pwm_dev[ch_id].cfg.duty = duty;

#if 0
    /* timer channel configuration in PWM mode0 */
    pwm_config = &pwm_dev[ch_id];
    timer_channel_output_pulse_value_config(pwm_config->timer, pwm_config->channel, duty);
    timer_channel_output_mode_config(pwm_config->timer, pwm_config->channel, TIMER_OC_MODE_PWM0);
    timer_channel_output_shadow_config(pwm_config->timer, pwm_config->channel, TIMER_OC_SHADOW_DISABLE);

    timer_auto_reload_shadow_enable(pwm_config->timer);
    timer_enable(pwm_config->timer);
#endif
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm frequency set
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] frequency: pwm frequency
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_frequency_set(TUYA_PWM_NUM_E ch_id, UINT32_T frequency)
{
    // --- BEGIN: user implements ---
    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

     if ((frequency < 2500) || (frequency  > SystemCoreClock))
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    /* stop first */
    tkl_pwm_stop(ch_id);
    pwm_dev[ch_id].cfg.frequency = frequency;
    //tkl_pwm_start(ch_id);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm polarity set
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] polarity: pwm polarity
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_polarity_set(TUYA_PWM_NUM_E ch_id, TUYA_PWM_POLARITY_E polarity)
{
    // --- BEGIN: user implements ---
    pwm_dev_config_t *pwm_config = NULL;
    timer_oc_parameter_struct timer_ocintpara = {0};

    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    /* stop first */
    tkl_pwm_stop(ch_id);

    pwm_dev[ch_id].cfg.polarity = polarity;

#if 0
    /* timer's channel configuration in PWM mode */
    timer_ocintpara.outputstate  = TIMER_CCX_ENABLE;
    timer_ocintpara.outputnstate = TIMER_CCXN_DISABLE;
    if (polarity == TUYA_PWM_NEGATIVE) {
        timer_ocintpara.ocpolarity   = TIMER_OC_POLARITY_LOW;
        timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;
        timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_HIGH;
        timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_HIGH;
    } else if (polarity == TUYA_PWM_POSITIVE) {
        timer_ocintpara.ocpolarity   = TIMER_OC_POLARITY_HIGH;
        timer_ocintpara.ocnpolarity  = TIMER_OCN_POLARITY_HIGH;
        timer_ocintpara.ocidlestate  = TIMER_OC_IDLE_STATE_LOW;
        timer_ocintpara.ocnidlestate = TIMER_OCN_IDLE_STATE_LOW;
    }

    pwm_config = &pwm_dev[ch_id];
    timer_channel_output_config(pwm_config->timer, pwm_config->channel, &timer_ocintpara);

    timer_auto_reload_shadow_enable(pwm_config->timer);
    timer_enable(pwm_config->timer);
#endif
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set pwm info
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] info: pwm info
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_info_set(TUYA_PWM_NUM_E ch_id, CONST TUYA_PWM_BASE_CFG_T *info)
{
    // --- BEGIN: user implements ---
    return tkl_pwm_init(ch_id, info);
    // --- END: user implements ---
}

/**
 * @brief get pwm info
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[out] info: pwm info
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_info_get(TUYA_PWM_NUM_E ch_id, TUYA_PWM_BASE_CFG_T *info)
{
    // --- BEGIN: user implements ---
    if ((ch_id >= TUYA_PWM_NUM_MAX) || !info)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    sys_memcpy(info, &pwm_dev[ch_id].cfg, sizeof(TUYA_PWM_BASE_CFG_T));

    return OPRT_OK;
    // --- END: user implements ---
}


typedef struct pwm_cap_irq {
    TUYA_PWM_IRQ_CB cb;   /* pwm irq cb */
    VOID_T          *arg; /* arg which would be passed to the irq cb */
    TUYA_PWM_POLARITY_E cap_edge;
    TUYA_PWM_CAPTURE_MODE_E cap_mode;
} pwm_cap_irq_t;

static pwm_cap_irq_t pwm_cap_irqs[TUYA_PWM_NUM_MAX] = {0};

static TUYA_PWM_NUM_E timer_to_ch_id (UINT32_T timer)
{
    UINT8_T i = 0;

    for (i = 0; i < TUYA_PWM_NUM_MAX; i++) {
        if (pwm_dev[i].timer == timer)
            break;
    }

    return i;
}

void pwm_cap_irq_hdl(UINT32_T timer)
{
    TUYA_PWM_NUM_E ch_id = timer_to_ch_id(timer);
    pwm_cap_irq_t *irq;
    TUYA_PWM_CAPTURE_DATA_T data = {0};

    if (ch_id != TUYA_PWM_NUM_MAX) {
        /* read channel 0 capture value */
        irq = &pwm_cap_irqs[ch_id];

        if(SET == timer_interrupt_flag_get(timer,TIMER_INT_FLAG_CH0)) {
            /* clear channel 0 interrupt bit */
            timer_interrupt_flag_clear(timer, TIMER_INT_FLAG_CH0);
            data.cap_value = timer_channel_capture_value_register_read(timer, TIMER_CH_0) + 1;
            if (data.cap_value == 1) {
                return;
            }
            data.cap_edge = irq->cap_edge;
            irq->cb(ch_id, data, irq->arg);

            if (irq->cap_mode == TUYA_PWM_CAPTURE_MODE_ONCE) {
                tkl_pwm_cap_stop(ch_id);
            }
        }
    }
}

static void eclic_pwm_cap_irq_enable(TUYA_PWM_NUM_E ch_id)
{
    switch (pwm_dev[ch_id].timer) {
    case TIMER0:
        eclic_irq_enable(TIMER0_Channel_IRQn, 8, 0);
        break;
    // case TIMER1:
    //     eclic_irq_enable(TIMER1_IRQn, 8, 0);
    //     break;
    // case TIMER2:
    //     eclic_irq_enable(TIMER2_IRQn, 8, 0);
    //     break;
    case TIMER15:
        eclic_irq_enable(TIMER15_IRQn, 8, 0);
        break;
    case TIMER16:
        eclic_irq_enable(TIMER16_IRQn, 8, 0);
        break;
    default:
        break;
    }
}

/**
 * @brief pwm capture mode start
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 * @param[in] cfg: pwm capture irq config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_cap_start(TUYA_PWM_NUM_E ch_id, CONST TUYA_PWM_CAP_IRQ_T *cfg)
{
    // --- BEGIN: user implements ---
    timer_ic_parameter_struct timer_icinitpara = {0};
    timer_parameter_struct timer_initpara = {0};
    pwm_dev_config_t *pwm_device = NULL;

    if (ch_id >= TUYA_PWM_NUM_MAX || cfg == NULL || cfg->cb == NULL)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    /* register irqs */
    pwm_cap_irqs[ch_id].cb = cfg->cb;
    pwm_cap_irqs[ch_id].arg = cfg->arg;
    pwm_cap_irqs[ch_id].cap_edge = cfg->trigger_level;
    pwm_cap_irqs[ch_id].cap_mode = cfg->cap_mode;

    /* enable interrupt */
    eclic_pwm_cap_irq_enable(ch_id);

    /* get device struct */
    pwm_device = &pwm_dev[ch_id];
    pwm_dev_rcu_enable(ch_id);
    pwm_gpio_config(ch_id);

    /* deinit first */
    timer_deinit(pwm_device->timer);

    /* TIMER2 configuration */
    timer_initpara.prescaler = (SystemCoreClock / cfg->clk) - 1;
    timer_initpara.alignedmode       = TIMER_COUNTER_EDGE;
    timer_initpara.counterdirection  = TIMER_COUNTER_UP;
    timer_initpara.period            = 65535;
    timer_initpara.clockdivision     = TIMER_CKDIV_DIV1;
    timer_initpara.repetitioncounter = 0;
    timer_init(pwm_device->timer, &timer_initpara);

    /* timer configuration */
    /* timer channel 0 PWM input capture configuration */
    if (cfg->trigger_level == TUYA_PWM_NEGATIVE) {
        timer_icinitpara.icpolarity  = TIMER_IC_POLARITY_FALLING;
    } else if (cfg->trigger_level == TUYA_PWM_POSITIVE) {
        timer_icinitpara.icpolarity  = TIMER_IC_POLARITY_RISING;
    }
    timer_icinitpara.icselection = TIMER_IC_SELECTION_DIRECTTI;
    timer_icinitpara.icprescaler = TIMER_IC_PSC_DIV1;
    timer_icinitpara.icfilter    = 0x0;
    timer_input_pwm_capture_config(pwm_device->timer, TIMER_CH_0,  &timer_icinitpara);
    /* channel 0 slave mode selection */
    timer_input_trigger_source_select(pwm_device->timer, TIMER_SMCFG_TRGSEL_CI0FE0);

    /* auto-reload preload enable */
    if (cfg->cap_mode == TUYA_PWM_CAPTURE_MODE_ONCE) {
        /* single pulse mode selection */
        timer_slave_mode_select(pwm_device->timer, TIMER_SLAVE_MODE_PAUSE);
        /* select the master slave mode */
        timer_master_slave_mode_config(pwm_device->timer, TIMER_MASTER_SLAVE_MODE_ENABLE);
        timer_auto_reload_shadow_enable(pwm_device->timer);
    } else if (cfg->cap_mode == TUYA_PWM_CAPTURE_MODE_PERIOD) {
        timer_slave_mode_select(pwm_device->timer, TIMER_SLAVE_MODE_RESTART);
        /* select the master slave mode */
        timer_master_slave_mode_config(pwm_device->timer, TIMER_MASTER_SLAVE_MODE_ENABLE);
        timer_auto_reload_shadow_enable(pwm_device->timer);
    }

    /* clear channel 0 interrupt bit */
    timer_interrupt_flag_clear(pwm_device->timer, TIMER_INT_FLAG_CH0);
    /* channel 0 interrupt enable */
    timer_interrupt_enable(pwm_device->timer, TIMER_INT_CH0);

    /* TIMER counter enable */
    timer_enable(pwm_device->timer);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief pwm capture mode stop
 *
 * @param[in] ch_id: pwm channal id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_pwm_cap_stop(TUYA_PWM_NUM_E ch_id)
{
    // --- BEGIN: user implements ---
    if (ch_id >= TUYA_PWM_NUM_MAX)
        return OPRT_OS_ADAPTER_PWM_INVALID_PARM;

    timer_auto_reload_shadow_disable(pwm_dev[ch_id].timer);
    timer_interrupt_disable(pwm_dev[ch_id].timer, TIMER_INT_CH0);
    timer_disable(pwm_dev[ch_id].timer);

    return OPRT_OK;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
