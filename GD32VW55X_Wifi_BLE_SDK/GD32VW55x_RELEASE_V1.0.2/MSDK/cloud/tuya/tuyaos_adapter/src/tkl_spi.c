/**
 * @file tkl_spi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "gd32vw55x.h"
#include "tkl_spi.h"
#include "tuya_error_code.h"
#include "gd32vw55x_spi.h"
#include "gd32vw55x_rcu.h"
#include "wrapper_os.h"
#include "dbg_print.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT

#define SPI_DEV_NUM             1

#define SPI_DMA_RX              DMA_CH0
#define SPI_DMA_TX              DMA_CH4

#define SPI_SEND_OP_MSK         0x01
#define SPI_RECV_OP_MSK         0x02
#define SPI_TRANS_SEND_OP_MSK   0x04
#define SPI_TRANS_RECV_OP_MSK   0x08
#define SPI_DMA_SEND_CMPLT_MSK  0x10
#define SPI_DMA_RECV_CMPL_MSK   0x20

#define SET_SPI_NSS_HIGH        gpio_bit_set(GPIOA, GPIO_PIN_12)
#define SET_SPI_NSS_LOW         gpio_bit_reset(GPIOA, GPIO_PIN_12)

typedef struct spi_env
{
    TUYA_SPI_ROLE_E       role;
    spi_parameter_struct  spi_param;
    UINT8_T               op_msk;
    TUYA_SPI_STATUS_T     status;
    VOID_T* send_buf;
    VOID_T* receive_buf;
} spi_env_t;

static spi_env_t spi_env_info;
static BOOL_T spi_irq_en = FALSE;
static TUYA_SPI_IRQ_CB spi_irq_cb = NULL;

static void tkl_spi_disable_irqs()
{
    if (spi_irq_en) {
        spi_interrupt_disable(SPI_INT_TBE);
        spi_interrupt_disable(SPI_INT_RBNE);
        spi_interrupt_disable(SPI_INT_ERR);
    }
}

static void tkl_spi_tx_dma_conf(VOID_T *data, UINT16_T size)
{
    dma_single_data_parameter_struct dma_init_struct;

    dma_single_data_para_struct_init(&dma_init_struct);
    dma_deinit(SPI_DMA_TX);
    dma_init_struct.periph_addr         = (uint32_t)&SPI_DATA;
    dma_init_struct.memory0_addr        = (uint32_t)data;
    dma_init_struct.direction           = DMA_MEMORY_TO_PERIPH;
    if (spi_env_info.spi_param.frame_size == SPI_FRAMESIZE_8BIT) {
        dma_init_struct.periph_memory_width = DMA_MEMORY_WIDTH_8BIT;
    } else {
        dma_init_struct.periph_memory_width = DMA_MEMORY_WIDTH_16BIT;
    }
    dma_init_struct.priority            = DMA_PRIORITY_LOW;
    dma_init_struct.number              = size;
    dma_init_struct.periph_inc          = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.memory_inc          = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.circular_mode       = DMA_CIRCULAR_MODE_DISABLE;
    dma_single_data_mode_init(SPI_DMA_TX, &dma_init_struct);
    dma_channel_subperipheral_select(SPI_DMA_TX, DMA_SUBPERI3);

    dma_interrupt_flag_clear(SPI_DMA_TX, DMA_INT_FLAG_FTF);
    dma_interrupt_flag_clear(SPI_DMA_TX, DMA_INT_FLAG_FEE);

    if (spi_irq_en) {
        dma_interrupt_enable(SPI_DMA_TX, DMA_INT_FTF);
        dma_interrupt_enable(SPI_DMA_TX, DMA_INT_FEE);
    } else {
        dma_interrupt_disable(SPI_DMA_TX, DMA_INT_FTF);
        dma_interrupt_disable(SPI_DMA_TX, DMA_INT_FEE);
    }

    /* SPI_Tx DMA channel */
    dma_channel_enable(SPI_DMA_TX);
}

static void tkl_spi_rx_dma_conf(VOID_T *data, UINT16_T size)
{
    dma_single_data_parameter_struct dma_init_struct;

    dma_single_data_para_struct_init(&dma_init_struct);
    dma_deinit(SPI_DMA_RX);
    dma_init_struct.periph_addr         = (uint32_t)&SPI_DATA;
    dma_init_struct.memory0_addr        = (uint32_t)data;
    dma_init_struct.direction           = DMA_PERIPH_TO_MEMORY;
    if (spi_env_info.spi_param.frame_size == SPI_FRAMESIZE_8BIT) {
        dma_init_struct.periph_memory_width = DMA_MEMORY_WIDTH_8BIT;
    } else {
        dma_init_struct.periph_memory_width = DMA_MEMORY_WIDTH_16BIT;
    }
    dma_init_struct.priority            = DMA_PRIORITY_HIGH;
    dma_init_struct.number              = size;
    dma_init_struct.periph_inc          = DMA_PERIPH_INCREASE_DISABLE;
    dma_init_struct.memory_inc          = DMA_MEMORY_INCREASE_ENABLE;
    dma_init_struct.circular_mode       = DMA_CIRCULAR_MODE_DISABLE;
    dma_single_data_mode_init(SPI_DMA_RX, &dma_init_struct);
    dma_channel_subperipheral_select(SPI_DMA_RX, DMA_SUBPERI3);

    dma_interrupt_flag_clear(SPI_DMA_RX, DMA_INT_FLAG_FTF);
    dma_interrupt_flag_clear(SPI_DMA_RX, DMA_INT_FLAG_FEE);

    if (spi_irq_en) {
        dma_interrupt_enable(SPI_DMA_RX, DMA_INT_FTF);
        dma_interrupt_enable(SPI_DMA_RX, DMA_INT_FEE);
    } else {
        dma_interrupt_disable(SPI_DMA_RX, DMA_INT_FTF);
        dma_interrupt_disable(SPI_DMA_RX, DMA_INT_FEE);
    }

    /* SPI_Rx DMA channel */
    dma_channel_enable(SPI_DMA_RX);
}


void DMA_Channel4_IRQHandler(void)
{
    //dbg_print(ERR, "DMA_Channel4_IRQHandler op_msk 0x%x \r\n", spi_env_info.op_msk);
    if (RESET != dma_interrupt_flag_get(SPI_DMA_TX, DMA_INT_FLAG_FEE)) {
        if (spi_irq_cb) {
            spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_DATA_LOST);
        }
        spi_env_info.status.data_lost = 1;
        spi_env_info.op_msk = 0;
        dma_interrupt_flag_clear(SPI_DMA_TX, DMA_INT_FLAG_FEE);
    } else if (RESET != dma_interrupt_flag_get(SPI_DMA_TX, DMA_INT_FLAG_FTF)) {
        if (spi_env_info.op_msk & (SPI_TRANS_SEND_OP_MSK | SPI_TRANS_RECV_OP_MSK)) {
            spi_env_info.op_msk &= (~SPI_TRANS_SEND_OP_MSK);
            if (spi_irq_cb) {
                if (spi_env_info.op_msk == 0) {
                    spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_TRANSFER_COMPLETE);
                }
                // Wait for receive complete
            }
        } else {
            spi_env_info.op_msk |= SPI_DMA_SEND_CMPLT_MSK;
        }
        dma_interrupt_flag_clear(SPI_DMA_TX, DMA_INT_FLAG_FTF);
    }

    if (spi_env_info.op_msk == 0) {
        if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
            if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE || spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
                spi_nss_internal_high();
            } else
                SET_SPI_NSS_HIGH;
        }
        spi_dma_disable(SPI_DMA_TRANSMIT);
        spi_dma_disable(SPI_DMA_RECEIVE);
        tkl_spi_disable_irqs();

        spi_disable();
    }

    if (spi_env_info.send_buf == NULL) {
        sys_mfree(spi_env_info.send_buf);
        spi_env_info.send_buf = NULL;
    }
}

void DMA_Channel0_IRQHandler(void)
{
    //dbg_print(ERR, "DMA_Channel0_IRQHandler op_msk 0x%x \r\n", spi_env_info.op_msk);
    if (RESET != dma_interrupt_flag_get(SPI_DMA_RX, DMA_INT_FLAG_FEE)) {
        if (spi_irq_cb) {
            spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_DATA_LOST);
        }
        spi_env_info.status.data_lost = 1;
        spi_env_info.op_msk = 0;
        dma_interrupt_flag_clear(SPI_DMA_RX, DMA_INT_FLAG_FEE);
    } else if(RESET != dma_interrupt_flag_get(SPI_DMA_RX, DMA_INT_FLAG_FTF)) {
        if (spi_env_info.op_msk & (SPI_TRANS_SEND_OP_MSK | SPI_TRANS_RECV_OP_MSK)) {
            spi_env_info.op_msk &= (~SPI_TRANS_RECV_OP_MSK);
            if (spi_irq_cb) {
                if (spi_env_info.op_msk == 0) {
                    spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_TRANSFER_COMPLETE);
                }
                // Wait for send complete
            }
        } else {
            spi_env_info.op_msk = 0;
            if (spi_irq_cb) {
                spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_RX_COMPLETE);
            }
        }
        dma_interrupt_flag_clear(SPI_DMA_RX, DMA_INT_FLAG_FTF);
    }

    if (spi_env_info.op_msk == 0) {
        if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
            if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE || spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
                spi_nss_internal_high();
            } else
                SET_SPI_NSS_HIGH;
        }

        spi_dma_disable(SPI_DMA_TRANSMIT);
        spi_dma_disable(SPI_DMA_RECEIVE);
        tkl_spi_disable_irqs();

        spi_disable();
    }

    if (spi_env_info.receive_buf == NULL) {
        sys_mfree(spi_env_info.receive_buf);
        spi_env_info.receive_buf = NULL;
    }
}


void SPI_IRQHandler(void)
{
    //dbg_print(ERR, "SPI_IRQHandler op_msk 0x%x \r\n", spi_env_info.op_msk);
    if (SET == spi_interrupt_flag_get(SPI_INT_FLAG_RXORERR)) {
        if (spi_env_info.op_msk != 0) {
            if (spi_irq_cb) {
                spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_DATA_LOST);
            }
            spi_env_info.status.data_lost = 1;
            spi_env_info.op_msk = 0;
        }

        // Clear flag
        spi_data_receive();
        spi_flag_get(SPI_INT_FLAG_RXORERR);
    } else if (SET == spi_interrupt_flag_get(SPI_INT_FLAG_CONFERR)) {
        if (spi_irq_cb) {
            spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_MODE_FAULT);
        }
        spi_env_info.status.mode_fault = 1;
        spi_env_info.op_msk = 0;
    } else if (spi_env_info.op_msk & SPI_SEND_OP_MSK) {
        if ((spi_env_info.op_msk & SPI_DMA_SEND_CMPLT_MSK) && RESET == spi_flag_get(SPI_FLAG_TRANS)) {
            if (spi_irq_cb) {
                spi_irq_cb(TUYA_SPI_NUM_0, TUYA_SPI_EVENT_TX_COMPLETE);
            }
            spi_env_info.op_msk = 0;
        }
    }


    if (spi_env_info.op_msk == 0) {
        if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
            if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE || spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
                spi_nss_internal_high();
            } else
                SET_SPI_NSS_HIGH;
        }
        spi_dma_disable(SPI_DMA_TRANSMIT);
        spi_dma_disable(SPI_DMA_RECEIVE);
        tkl_spi_disable_irqs();

        spi_disable();
    }
}

/**
 * @brief spi init
 *
 * @param[in] port: spi port
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_init(TUYA_SPI_NUM_E port, CONST TUYA_SPI_BASE_CFG_T *cfg)
{
    uint16_t psc = 0;

    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    } else if (cfg->role == TUYA_SPI_ROLE_INACTIVE || cfg->freq_hz > 160000000) {
        return OPRT_INVALID_PARM;
    }

    spi_deinit();

    /* wait for SPI stability */
    sys_ms_sleep(10);

    sys_memset(&spi_env_info, 0, sizeof(spi_env_t));

    rcu_periph_clock_enable(RCU_SPI);
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_DMA);

    // PA11: SPI_SCK
    gpio_af_set(GPIOA, GPIO_AF_0, GPIO_PIN_11);
    gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_11);
    gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_11);

    spi_env_info.role = cfg->role;

    if (spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
        spi_env_info.spi_param.device_mode = SPI_MASTER;
        // PA9: SPI_MOSI
        gpio_af_set(GPIOA, GPIO_AF_0, GPIO_PIN_9);
        gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_9);
        gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_9);
    } else if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
        spi_env_info.spi_param.device_mode = SPI_SLAVE;
        // PA10: SPI_MISO
        gpio_af_set(GPIOA, GPIO_AF_0, GPIO_PIN_10);
        gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_10);
        gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_10);
    } else {
        // PA9: SPI_MOSI, PA10: SPI_MISO
        gpio_af_set(GPIOA, GPIO_AF_0, GPIO_PIN_10 | GPIO_PIN_9);
        if (cfg->role == TUYA_SPI_ROLE_MASTER) {
            gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_10 | GPIO_PIN_9);
        } else {
            gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_PULLDOWN, GPIO_PIN_10 | GPIO_PIN_9);
        }
        gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_10 | GPIO_PIN_9);
        spi_env_info.spi_param.trans_mode = SPI_TRANSMODE_FULLDUPLEX;
        spi_env_info.spi_param.device_mode = cfg->role == TUYA_SPI_ROLE_MASTER ? SPI_MASTER : SPI_SLAVE;
    }

    switch (cfg->mode) {
    case TUYA_SPI_MODE0:
        spi_env_info.spi_param.clock_polarity_phase = SPI_CK_PL_LOW_PH_1EDGE;
        break;

    case TUYA_SPI_MODE1:
        spi_env_info.spi_param.clock_polarity_phase = SPI_CK_PL_LOW_PH_2EDGE;
        break;

    case TUYA_SPI_MODE2:
        spi_env_info.spi_param.clock_polarity_phase = SPI_CK_PL_HIGH_PH_1EDGE;
        break;

    case TUYA_SPI_MODE3:
        spi_env_info.spi_param.clock_polarity_phase = SPI_CK_PL_HIGH_PH_2EDGE;
        break;

    default:
        dbg_print(ERR, "unknown spi mode \r\n");
        return OPRT_INVALID_PARM;
    }

    if (cfg->type == TUYA_SPI_SOFT_TYPE || cfg->type == TUYA_SPI_SOFT_ONE_WIRE_TYPE) {
        spi_env_info.spi_param.nss = SPI_NSS_SOFT;
        if (spi_env_info.role == TUYA_SPI_ROLE_MASTER || spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
            // Need to remove when mater in software mode
            // PA12: SPI_NSS
            gpio_mode_set(GPIOA, GPIO_MODE_OUTPUT, GPIO_PUPD_NONE, GPIO_PIN_12);
            gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_12);
        }
    } else {
        spi_env_info.spi_param.nss = SPI_NSS_HARD;
        // PA12: SPI_NSS
        gpio_af_set(GPIOA, GPIO_AF_6, GPIO_PIN_12);
        gpio_mode_set(GPIOA, GPIO_MODE_AF, GPIO_PUPD_NONE, GPIO_PIN_12);
        gpio_output_options_set(GPIOA, GPIO_OTYPE_PP, GPIO_OSPEED_10MHZ, GPIO_PIN_12);
    }

    if (cfg->databits == TUYA_SPI_DATA_BIT8) {
        spi_env_info.spi_param.frame_size = SPI_FRAMESIZE_8BIT;
    } else {
        spi_env_info.spi_param.frame_size = SPI_FRAMESIZE_16BIT;
    }

    if (cfg->bitorder == TUYA_SPI_ORDER_MSB2LSB) {
        spi_env_info.spi_param.endian = SPI_ENDIAN_MSB;
    } else {
        spi_env_info.spi_param.endian = SPI_ENDIAN_LSB;
    }

    if (cfg->freq_hz == 0) {
        psc = 256;
    } else {
        psc = 160000000 / cfg->freq_hz;
    }

    switch (psc) {
    case 2:
        spi_env_info.spi_param.prescale = SPI_PSC_2;
    break;

    case 4:
        spi_env_info.spi_param.prescale = SPI_PSC_4;
    break;

    case 8:
        spi_env_info.spi_param.prescale = SPI_PSC_8;
    break;

    case 16:
        spi_env_info.spi_param.prescale = SPI_PSC_16;
    break;

    case 32:
        spi_env_info.spi_param.prescale = SPI_PSC_32;
    break;

    case 64:
        spi_env_info.spi_param.prescale = SPI_PSC_64;
    break;

    case 128:
        spi_env_info.spi_param.prescale = SPI_PSC_128;
    break;

    case 256:
        spi_env_info.spi_param.prescale = SPI_PSC_256;
    break;

    default:
      spi_env_info.spi_param.prescale = SPI_PSC_256;
    break;
    }

    spi_disable();

    return OPRT_OK;
}

/**
 * @brief spi deinit
 *
 * @param[in] port: spi port
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_deinit(TUYA_SPI_NUM_E port)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.op_msk != 0) {
        tkl_spi_disable_irqs();
        dma_channel_disable(SPI_DMA_TX);
        dma_channel_disable(SPI_DMA_RX);

        if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
            if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE || spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
                spi_nss_internal_high();
            } else
                SET_SPI_NSS_HIGH;
        }
        spi_dma_disable(SPI_DMA_TRANSMIT);
        spi_dma_disable(SPI_DMA_RECEIVE);
        spi_disable();
        spi_env_info.op_msk = 0;
    }

    spi_deinit();
    /* wait for SPI stability */
    sys_ms_sleep(10);

    if (spi_env_info.send_buf == NULL) {
        sys_mfree(spi_env_info.send_buf);
        spi_env_info.send_buf = NULL;
    }

    if (spi_env_info.receive_buf == NULL) {
        sys_mfree(spi_env_info.receive_buf);
        spi_env_info.receive_buf = NULL;
    }


    return OPRT_OK;
}

/**
 * Spi send
 *
 * @param[in]  port      the spi device
 * @param[in]  data     spi send data
 * @param[in]  size     spi send data size
 *
 * @return  OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_send(TUYA_SPI_NUM_E port, VOID_T *data, UINT16_T size)
{
    OPERATE_RET status = OPRT_OK;

    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
        spi_env_info.spi_param.trans_mode = SPI_TRANSMODE_BDTRANSMIT;
    } else if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
        spi_env_info.spi_param.trans_mode = SPI_TRANSMODE_BDTRANSMIT;
    } else {
        return tkl_spi_transfer(port, data, NULL, size);
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_HARD && spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
        spi_nss_output_enable();
    }

    spi_data_receive();
    spi_flag_get(SPI_INT_FLAG_CONFERR);

    spi_init(&spi_env_info.spi_param);

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    if (spi_irq_en) {
        spi_interrupt_enable(SPI_INT_TBE);
        spi_interrupt_enable(SPI_INT_RBNE);
        spi_interrupt_enable(SPI_INT_ERR);
    }

    spi_env_info.op_msk = SPI_SEND_OP_MSK;
    tkl_spi_tx_dma_conf(data, size);
    spi_dma_enable(SPI_DMA_TRANSMIT);

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_low();
        } else
            SET_SPI_NSS_LOW;
    }

    spi_enable();

    // Wait for DMA transfer complete interrupt
    if (spi_irq_en) {
        return OPRT_OK;
    } else {
        while(1) {
            if (SET == dma_flag_get(SPI_DMA_TX, DMA_FLAG_FTF) && RESET == spi_flag_get(SPI_FLAG_TRANS)) {
                status = OPRT_OK;
                break;
            } else if (SET == dma_flag_get(SPI_DMA_TX, DMA_FLAG_FEE)) {
                status = OPRT_OS_ADAPTER_SPI_TRANS_ERR;
                spi_env_info.op_msk = 0;
                break;
            }
        }
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    spi_env_info.op_msk = 0;
    tkl_spi_disable_irqs();

    spi_dma_disable(SPI_DMA_TRANSMIT);
    dma_channel_disable(SPI_DMA_TX);

    spi_disable();

    return status;
}

/**
 * spi_recv
 *
 * @param[in]   port      the spi device
 * @param[out]  data     spi recv data
 * @param[in]   size     spi recv data size
 *
 * @return  OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_recv(TUYA_SPI_NUM_E port, VOID_T *data, UINT16_T size)
{
    OPERATE_RET status = OPRT_OK;

    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
        spi_env_info.spi_param.trans_mode = SPI_TRANSMODE_BDRECEIVE;
    } else if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
        spi_env_info.spi_param.trans_mode = SPI_TRANSMODE_BDRECEIVE;
    } else {
        return tkl_spi_transfer(port, NULL, data, size);
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_HARD  && spi_env_info.role == TUYA_SPI_ROLE_MASTER_SIMPLEX) {
        spi_nss_output_enable();
    }

    spi_data_receive();
    spi_flag_get(SPI_INT_FLAG_CONFERR);

    if (spi_irq_en) {
        spi_interrupt_enable(SPI_INT_RBNE);
        spi_interrupt_enable(SPI_INT_ERR);
    }

    spi_init(&spi_env_info.spi_param);

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    spi_env_info.op_msk = SPI_RECV_OP_MSK;
    tkl_spi_rx_dma_conf(data, size);
    spi_dma_enable(SPI_DMA_RECEIVE);

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_low();
        } else
            SET_SPI_NSS_LOW;
    }

    spi_enable();

    // Wait for DMA transfer complete interrupt
    if (spi_irq_en) {
        return OPRT_OK;
    } else {
        while(1) {
            if (SET == dma_flag_get(SPI_DMA_RX, DMA_FLAG_FTF)) {
                status = OPRT_OK;
                break;
            } else if (SET == dma_flag_get(SPI_DMA_RX, DMA_FLAG_FEE)) {
                status = OPRT_OS_ADAPTER_SPI_TRANS_ERR;
                spi_env_info.op_msk = 0;
                break;
            }
        }
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    spi_env_info.op_msk = 0;
    spi_dma_disable(SPI_DMA_RECEIVE);
    dma_channel_disable(SPI_DMA_RX);
    tkl_spi_disable_irqs();

    spi_disable();

    return status;
}

/**
 * @brief spi transfer
 *
 * @param[in] port: spi port
 * @param[in] send_buf: spi send buf
 * @param[out] send_buf:spi recv buf
 * @param[in] length: spi msg length
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_transfer(TUYA_SPI_NUM_E port, VOID_T* send_buf, VOID_T* receive_buf, UINT32_T length)
{
    OPERATE_RET status = OPRT_OK;

    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.role != TUYA_SPI_ROLE_MASTER && spi_env_info.role != TUYA_SPI_ROLE_SLAVE)
        return OPRT_NOT_SUPPORTED;

    if (send_buf == NULL || receive_buf == NULL) {
        uint8_t unit = spi_env_info.spi_param.frame_size == SPI_FRAMESIZE_8BIT ? 1 : 2;

        if (send_buf == NULL) {
            spi_env_info.send_buf = sys_malloc(unit *length);
            if (spi_env_info.send_buf == NULL) {
                status = OPRT_MALLOC_FAILED;
                goto done;
            }
        }

        if (receive_buf == NULL) {
            spi_env_info.receive_buf = sys_malloc(unit *length);
            if (spi_env_info.receive_buf == NULL) {
                status = OPRT_MALLOC_FAILED;
                goto done;
            }
        }
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_HARD && spi_env_info.role == TUYA_SPI_ROLE_MASTER) {
        // NSS output mode
        spi_nss_output_enable();
    }

    spi_data_receive();
    spi_flag_get(SPI_INT_FLAG_CONFERR);

    spi_init(&spi_env_info.spi_param);

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    spi_env_info.op_msk = SPI_TRANS_SEND_OP_MSK | SPI_TRANS_RECV_OP_MSK;
    tkl_spi_rx_dma_conf(receive_buf, length);
    tkl_spi_tx_dma_conf(send_buf, length);

    spi_dma_enable(SPI_DMA_TRANSMIT);
    spi_dma_enable(SPI_DMA_RECEIVE);

    if (spi_irq_en) {
        spi_interrupt_enable(SPI_INT_ERR);
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE) {
            spi_nss_internal_low();
        } else
            SET_SPI_NSS_LOW;
    }

    spi_enable();

    // Wait for DMA transfer complete interrupt
    if (spi_irq_en) {
        return OPRT_OK;
    } else {
        while(1) {
            if (SET == dma_flag_get(SPI_DMA_RX, DMA_FLAG_FTF) && SET == dma_flag_get(SPI_DMA_TX, DMA_FLAG_FTF)) {
                status = OPRT_OK;
                break;
            } else if (SET == dma_flag_get(SPI_DMA_RX, DMA_FLAG_FEE) || SET == dma_flag_get(SPI_DMA_TX, DMA_FLAG_FEE)) {
                dbg_print(ERR, "tkl_spi_transfer dma err \r\n");
                status = OPRT_OS_ADAPTER_SPI_TRANS_ERR;
                spi_env_info.op_msk = 0;
                break;
            }
        }
    }

    if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
        if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE) {
            spi_nss_internal_high();
        } else
            SET_SPI_NSS_HIGH;
    }

    spi_env_info.op_msk = 0;
    spi_dma_disable(SPI_DMA_TRANSMIT);
    spi_dma_disable(SPI_DMA_RECEIVE);
    tkl_spi_disable_irqs();

    spi_disable();

done:
    if (spi_env_info.send_buf == NULL) {
        sys_mfree(spi_env_info.send_buf);
        spi_env_info.send_buf = NULL;
    }

    if (spi_env_info.receive_buf == NULL) {
        sys_mfree(spi_env_info.receive_buf);
        spi_env_info.receive_buf = NULL;
    }
    return status;
}

/**
 * @brief adort spi transfer,or spi send, or spi recv
 *
 * @param[in] port: spi port
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

OPERATE_RET tkl_spi_abort_transfer(TUYA_SPI_NUM_E port)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.op_msk != 0) {
        tkl_spi_disable_irqs();
        dma_channel_disable(SPI_DMA_TX);
        dma_channel_disable(SPI_DMA_RX);

        if (spi_env_info.spi_param.nss == SPI_NSS_SOFT) {
            if (spi_env_info.role == TUYA_SPI_ROLE_SLAVE || spi_env_info.role == TUYA_SPI_ROLE_SLAVE_SIMPLEX) {
                spi_nss_internal_high();
            } else
                SET_SPI_NSS_HIGH;
        }
        spi_dma_disable(SPI_DMA_TRANSMIT);
        spi_dma_disable(SPI_DMA_RECEIVE);
        spi_disable();

        spi_deinit();
        /* wait for SPI stability */
        sys_ms_sleep(10);
        spi_env_info.op_msk = 0;
    }

    if (spi_env_info.send_buf == NULL) {
        sys_mfree(spi_env_info.send_buf);
        spi_env_info.send_buf = NULL;
    }

    if (spi_env_info.receive_buf == NULL) {
        sys_mfree(spi_env_info.receive_buf);
        spi_env_info.receive_buf = NULL;
    }

    return OPRT_OK;
}

/**
 * @brief get spi status.
 *
 * @param[in] port: spi port
 * @param[out]  TUYA_SPI_STATUS_T,please refer to tuya_cloud_types.h
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_get_status(TUYA_SPI_NUM_E port, TUYA_SPI_STATUS_T *status)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    *status = spi_env_info.status;
    if (spi_env_info.op_msk != 0) {
        status->busy = 1;
    }

    return OPRT_OK;
}

/**
 * @brief spi irq init
 * NOTE: call this API will not enable interrupt
 *
 * @param[in] port: spi port, id index starts at 0
 * @param[in] cb:  spi irq cb
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_irq_init(TUYA_SPI_NUM_E port, TUYA_SPI_IRQ_CB cb)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    eclic_irq_enable(SPI_IRQn, 8, 0);
    // SPI_DMA_RX
    if (SPI_DMA_RX == DMA_CH2) {
        eclic_irq_enable(DMA_Channel2_IRQn, 8, 0);
    } else {
        eclic_irq_enable(DMA_Channel0_IRQn, 8, 0);
    }

    // SPI_DMA_TX
    if (SPI_DMA_TX == DMA_CH4) {
        eclic_irq_enable(DMA_Channel4_IRQn, 8, 0);
    } else {
        eclic_irq_enable(DMA_Channel3_IRQn, 8, 0);
    }

    spi_irq_cb = cb;
    return OPRT_OK;
}

/**
 * @brief spi irq enable
 *
 * @param[in] port: spi port id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_irq_enable(TUYA_SPI_NUM_E port)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    spi_irq_en = TRUE;
    return OPRT_OK;
}

/**
 * @brief spi irq disable
 *
 * @param[in] port: spi port id, id index starts at 0
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_irq_disable(TUYA_SPI_NUM_E port)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    tkl_spi_disable_irqs();

    spi_irq_en = FALSE;
    return OPRT_OK;
}

/**
 * @brief spi transferred data count.
 *
 * @param[in] port: spi port id, id index starts at 0
 *
 * @return >=0,number of currently transferred data items. <0,err.
 * during  tkl_spi_send, tkl_spi_recv and tkl_spi_transfer operation.
 */
INT32_T tkl_spi_get_data_count(TUYA_SPI_NUM_E port)
{
    if (port >= SPI_DEV_NUM) {
        return OPRT_NOT_SUPPORTED;
    }

    if (spi_env_info.op_msk == SPI_SEND_OP_MSK) {
        return (INT32_T)dma_transfer_number_get(DMA_CH4);
    } else if (spi_env_info.op_msk == SPI_RECV_OP_MSK) {
        return (INT32_T)dma_transfer_number_get(DMA_CH0);
    } else if (spi_env_info.op_msk != 0) {
        return (INT32_T)dma_transfer_number_get(DMA_CH4);
    }

    return 0;
}

/**
 * @brief spi ioctl
 *
 * @param[in]       cmd     user def
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_spi_ioctl(TUYA_SPI_NUM_E port, UINT32_T cmd,  VOID *args)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
