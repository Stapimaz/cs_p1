/**
 * @file tkl_timer.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "app_cfg.h"
#include "wrapper_os.h"
#include "gd32vw55x_timer.h"
#include "tkl_timer.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT
/**
 * @brief timer init
 *
 * @param[in] timer_id timer id
 * @param[in] cfg timer configure
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */

typedef struct timer_item
{
    UINT32_T timer;
    BOOL_T  used;
    UINT32_T timer_interval;
    TUYA_TIMER_BASE_CFG_T timer_cfg;
} timer_item_t;

static timer_item_t timer_map[TUYA_TIMER_NUM_MAX] = {
    {TIMER1, FALSE, 0, {0}},
    {TIMER2, FALSE, 0, {0}},
};

void timer_irq_hdl(UINT32_T timer)
{
    UINT8_T i = 0;

    for (; i < TUYA_TIMER_NUM_MAX; i++) {
        if (timer_map[i].timer == timer)
            break;
    }

    if ((i < TUYA_TIMER_NUM_MAX) && (SET == timer_interrupt_flag_get(timer, TIMER_INT_UP))) {
        timer_interrupt_flag_clear(timer, TIMER_INT_UP);
        timer_map[i].timer_cfg.cb(timer_map[i].timer_cfg.args);
    }
}

#if 0
static void timer_callback_transfer(void *p_tmr, void *p_arg)
{
    UINT8_T i = 0;

    for (; i < TUYA_TIMER_NUM_MAX; i++) {
        if (timer_map[i].timer == p_tmr) {
            timer_map[i].timer_cfg.cb(p_arg);
        }
    }
}
#endif

/*
    \brief      initialize a timer
    \param[in]  timer: pointer to the timer handle
    \param[in]  name: pointer to the timer name
    \param[in]  delay: the timeout in milliseconds
    \param[in]  periodic: whether it's periodic timer
    \param[in]  func: the timer call back function
    \param[in]  arg:the argument that will pass to the call back
    \param[out] none
    \retval     none
*/
OPERATE_RET tkl_timer_init(TUYA_TIMER_NUM_E timer_id, TUYA_TIMER_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    if (timer_id >= TUYA_TIMER_NUM_MAX) {
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;
    }

    if (cfg == NULL) {
        return OPRT_INVALID_PARM;
    }

    timer_map[timer_id].timer_cfg.mode = cfg->mode;
    timer_map[timer_id].timer_cfg.cb = cfg->cb;
    timer_map[timer_id].timer_cfg.args = cfg->args;
    timer_map[timer_id].used = TRUE;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief timer start
 *
 * @param[in] timer_id timer id
 * @param[in] us when to start
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_start(TUYA_TIMER_NUM_E timer_id, UINT_T us)
{
    // --- BEGIN: user implements ---
    if (us < 1000 || timer_id >= TUYA_TIMER_NUM_MAX) {
        /* timer can't not set cycle less than 1ms */
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;
    }

    if (timer_map[timer_id].used == FALSE)
        return OPRT_COM_ERROR;

    timer_parameter_struct timer_para;
    UINT32_T timer = timer_map[timer_id].timer;

    rcu_timer_clock_prescaler_config(RCU_TIMER_PSC_MUL4);

    switch (timer) {
    case TIMER1:
        rcu_periph_clock_enable(RCU_TIMER1);
        eclic_irq_enable(TIMER1_IRQn, 8, 0);
        break;
    case TIMER2:
        rcu_periph_clock_enable(RCU_TIMER2);
        eclic_irq_enable(TIMER2_IRQn, 8, 0);
        break;
    default:
        return OPRT_COM_ERROR;
    }

    timer_deinit(timer);
    timer_struct_para_init(&timer_para);

    timer_para.prescaler        = 159; // timer clock is 160MHz
    timer_para.period           = (UINT32_T)(us);
    timer_para.clockdivision    = TIMER_CKDIV_DIV1;
    timer_para.alignedmode      = TIMER_COUNTER_EDGE;
    timer_para.counterdirection = TIMER_COUNTER_UP;
    timer_init(timer, &timer_para);

    timer_interrupt_flag_clear(timer, TIMER_INT_FLAG_UP);
    timer_interrupt_enable(timer, TIMER_INT_UP);
    timer_enable(timer);

    timer_map[timer_id].timer_interval = us;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief timer stop
 *
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_stop(TUYA_TIMER_NUM_E timer_id)
{
    // --- BEGIN: user implements ---
    if (timer_id >= TUYA_TIMER_NUM_MAX)
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;

    // sys_timer_stop(&timer_map[timer_id].timer, FALSE);
    timer_disable(timer_map[timer_id].timer);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief timer deinit
 *
 * @param[in] timer_id timer id
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_deinit(TUYA_TIMER_NUM_E timer_id)
{
    // --- BEGIN: user implements ---
    if (timer_id >= TUYA_TIMER_NUM_MAX)
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;

    // sys_timer_delete(&timer_map[timer_id].timer);
    timer_deinit(timer_map[timer_id].timer);
    timer_map[timer_id].used = FALSE;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief current timer get
 *
 * @param[in] timer_id timer id
 * @param[out] us timer
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get_current_value(TUYA_TIMER_NUM_E timer_id, UINT_T *us)
{
    // --- BEGIN: user implements ---
    if (timer_id >= TUYA_TIMER_NUM_MAX)
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;

    if (us == NULL)
        return OPRT_INVALID_PARM;

    *us = timer_counter_read(timer_map[timer_id].timer);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief timer get
 *
 * @param[in] timer_id timer id
 * @param[out] us timer interval
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_timer_get(TUYA_TIMER_NUM_E timer_id, UINT_T *us)
{
    // --- BEGIN: user implements ---
    if (timer_id >= TUYA_TIMER_NUM_MAX)
        return OPRT_BASE_TIMEQ_TIMERID_UNVALID;

    if (us == NULL)
        return OPRT_INVALID_PARM;

    if (timer_map[timer_id].used == FALSE)
        return OPRT_BASE_TIMEQ_TIMERID_NOT_FOUND;

    *us = timer_map[timer_id].timer_interval;

    return OPRT_OK;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
