/**
 * @file tkl_uart.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include <ctype.h>
#include "gd32vw55x_usart.h"
#include "uart.h"
#include "cyclic_buffer.h"
#include "tkl_uart.h"
#include "tuya_error_code.h"
// --- END: user defines and implements ---

#ifdef TUYAOS_SUPPORT

typedef struct tuya_uart_cb_item
{
    TUYA_UART_NUM_E port_id;
    TUYA_UART_IRQ_CB callback;
} tuya_uart_cb_item_t;

static tuya_uart_cb_item_t uart_rx_cbs[TUYA_UART_NUM_MAX] = {
    {TUYA_UART_NUM_MAX, NULL},
    {TUYA_UART_NUM_MAX, NULL},
    {TUYA_UART_NUM_MAX, NULL},
};

static tuya_uart_cb_item_t uart_tx_cbs[TUYA_UART_NUM_MAX] = {
    {TUYA_UART_NUM_MAX, NULL},
    {TUYA_UART_NUM_MAX, NULL},
    {TUYA_UART_NUM_MAX, NULL},
};

static UINT8_T tuya_uart_irq_callback_register(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB callback, UINT8_T tx_or_rx)
{
    UINT8_T i = 0;

    if (tx_or_rx) {// 1 for tx
        for (i = 0; i < TUYA_UART_NUM_MAX; i++) {
            // uart port already register callback
            if (uart_tx_cbs[i].port_id == port_id) {
                uart_tx_cbs[i].callback = callback;
                break;
            } else if (uart_tx_cbs[i].port_id == TUYA_UART_NUM_MAX) {
                uart_tx_cbs[i].callback = callback;
                uart_tx_cbs[i].port_id = port_id;
                break;
            }
        }
    } else {// 0 for rx
        for (i = 0; i < TUYA_UART_NUM_MAX; i++) {
            // uart port already register callback
            if (uart_rx_cbs[i].port_id == port_id) {
                uart_rx_cbs[i].callback = callback;
                break;
            } else if (uart_rx_cbs[i].port_id == TUYA_UART_NUM_MAX) {
                uart_rx_cbs[i].callback = callback;
                uart_rx_cbs[i].port_id = port_id;
                break;
            }
        }
    }

    if (i == TUYA_UART_NUM_MAX) {
        return FALSE;
    }

    return TRUE;
}

/**
 * @brief uart init
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] cfg: uart config
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_init(TUYA_UART_NUM_E port_id, TUYA_UART_BASE_CFG_T *cfg)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph;
    rcu_periph_clock_enable(RCU_GPIOA);
    rcu_periph_clock_enable(RCU_GPIOB);

    if (port_id == TUYA_UART_NUM_0) {
        usart_periph = USART0;
        rcu_periph_clock_enable(RCU_USART0);

        gpio_af_set(USART0_TX_GPIO, USART0_TX_AF_NUM, USART0_TX_PIN);
        gpio_af_set(USART0_RX_GPIO, USART0_RX_AF_NUM, USART0_RX_PIN);
        gpio_mode_set(USART0_TX_GPIO, GPIO_MODE_AF, GPIO_PUPD_PULLUP, USART0_TX_PIN);
        gpio_output_options_set(USART0_TX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, USART0_TX_PIN);
        gpio_mode_set(USART0_RX_GPIO, GPIO_MODE_AF, GPIO_PUPD_PULLUP, USART0_RX_PIN);
        gpio_output_options_set(USART0_RX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, USART0_RX_PIN);

#ifdef CONFIG_PLATFORM_ASIC
        /* configure cts/rts */
        if (cfg->flowctrl == TUYA_UART_FLOWCTRL_RTSCTS) {
            gpio_af_set(USART0_CTS_GPIO, USART0_CTS_AF_NUM, USART0_CTS_PIN);
            gpio_af_set(USART0_RTS_GPIO, USART0_RTS_AF_NUM, USART0_RTS_PIN);
            gpio_mode_set(USART0_CTS_GPIO, GPIO_MODE_INPUT, GPIO_PUPD_NONE, USART0_CTS_PIN);
            gpio_output_options_set(USART0_CTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, USART0_CTS_PIN);
            gpio_mode_set(USART0_RTS_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, USART0_RTS_PIN);
            gpio_output_options_set(USART0_RTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, USART0_RTS_PIN);
        }
#endif
    } else if (port_id == TUYA_UART_NUM_1) {
        usart_periph = UART1;
        rcu_periph_clock_enable(RCU_UART1);

        gpio_af_set(UART1_TX_GPIO, UART1_TX_AF_NUM, UART1_TX_PIN);
        gpio_af_set(UART1_RX_GPIO, UART1_RX_AF_NUM, UART1_RX_PIN);
        gpio_mode_set(UART1_TX_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART1_TX_PIN);
        gpio_output_options_set(UART1_TX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART1_TX_PIN);
        gpio_mode_set(UART1_RX_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART1_RX_PIN);
        gpio_output_options_set(UART1_RX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART1_RX_PIN);

#ifdef CONFIG_PLATFORM_ASIC
        if (cfg->flowctrl == TUYA_UART_FLOWCTRL_RTSCTS) {
            /* configure cts/rts */
            gpio_af_set(UART1_CTS_GPIO, UART1_CTS_AF_NUM, UART1_CTS_PIN);
            gpio_af_set(UART1_RTS_GPIO, UART1_RTS_AF_NUM, UART1_RTS_PIN);
            gpio_mode_set(UART1_CTS_GPIO, GPIO_MODE_INPUT, GPIO_PUPD_NONE, UART1_CTS_PIN);
            gpio_output_options_set(UART1_CTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART1_CTS_PIN);
            gpio_mode_set(UART1_RTS_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART1_RTS_PIN);
            gpio_output_options_set(UART1_RTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART1_RTS_PIN);
        }
#endif
    } else if (port_id == TUYA_UART_NUM_2) {
        usart_periph = UART2;
        rcu_periph_clock_enable(RCU_UART2);

        gpio_af_set(UART2_TX_GPIO, UART2_TX_AF_NUM, UART2_TX_PIN);
        gpio_af_set(UART2_RX_GPIO, UART2_RX_AF_NUM, UART2_RX_PIN);
        gpio_mode_set(UART2_TX_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART2_TX_PIN);
        gpio_output_options_set(UART2_TX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART2_TX_PIN);
        gpio_mode_set(UART2_RX_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART2_RX_PIN);
        gpio_output_options_set(UART2_RX_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART2_RX_PIN);

#ifdef CONFIG_PLATFORM_ASIC
        if (cfg->flowctrl == TUYA_UART_FLOWCTRL_RTSCTS) {
            /* configure cts/rts */
            gpio_af_set(UART2_CTS_GPIO, UART2_CTS_AF_NUM, UART2_CTS_PIN);
            gpio_af_set(UART2_RTS_GPIO, UART2_RTS_AF_NUM, UART2_RTS_PIN);
            gpio_mode_set(UART2_CTS_GPIO, GPIO_MODE_INPUT, GPIO_PUPD_NONE, UART2_CTS_PIN);
            gpio_output_options_set(UART2_CTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART2_CTS_PIN);
            gpio_mode_set(UART2_RTS_GPIO, GPIO_MODE_AF, GPIO_PUPD_NONE, UART2_RTS_PIN);
            gpio_output_options_set(UART2_RTS_GPIO, GPIO_OTYPE_PP, GPIO_OSPEED_25MHZ, UART2_RTS_PIN);
        }
#endif
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    /* close printf buffer */
    setvbuf(stdout, NULL, _IONBF, 0);

    usart_deinit(usart_periph);
    usart_baudrate_set(usart_periph, cfg->baudrate);
    switch (cfg->parity) {
    case TUYA_UART_PARITY_TYPE_ODD:
        usart_parity_config(usart_periph, USART_PM_ODD);
        break;
    case TUYA_UART_PARITY_TYPE_EVEN:
        usart_parity_config(usart_periph, USART_PM_EVEN);
        break;
    case TUYA_UART_PARITY_TYPE_NONE:
    default:
        usart_parity_config(usart_periph, USART_PM_NONE);
        break;
    }

    if (cfg->databits == TUYA_UART_DATA_LEN_8BIT) {
        usart_word_length_set(usart_periph, USART_WL_8BIT);
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    switch (cfg->stopbits) {
    case TUYA_UART_STOP_LEN_2BIT:
        usart_stop_bit_set(usart_periph, USART_STB_2BIT);
        break;
    case TUYA_UART_STOP_LEN_1_5BIT1:
        usart_stop_bit_set(usart_periph, USART_STB_1_5BIT);
        break;
    case TUYA_UART_STOP_LEN_1BIT:
    default:
        usart_stop_bit_set(usart_periph, USART_STB_1BIT);
        break;
    }

    /* close printf buffer */
    setvbuf(stdout, NULL, _IONBF, 0);

    usart_receive_config(usart_periph, USART_RECEIVE_ENABLE);
    usart_transmit_config(usart_periph, USART_TRANSMIT_ENABLE);
    // usart_interrupt_enable(usart_periph, USART_INT_RBNE);
    usart_receive_fifo_enable(usart_periph);

    if (cfg->flowctrl == TUYA_UART_FLOWCTRL_RTSCTS) {
        usart_hardware_flow_rts_config(usart_periph, USART_RTS_ENABLE);
        usart_hardware_flow_cts_config(usart_periph, USART_CTS_ENABLE);
    } else {
        usart_hardware_flow_rts_config(usart_periph, USART_RTS_DISABLE);
        usart_hardware_flow_cts_config(usart_periph, USART_CTS_DISABLE);
    }

    usart_enable(usart_periph);
    usart_command_enable(usart_periph, USART_CMD_RXFCMD);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief uart deinit
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_deinit(TUYA_UART_NUM_E port_id)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph;

    if (port_id == TUYA_UART_NUM_0) {
        usart_periph = USART0;
    } else if (port_id == TUYA_UART_NUM_1) {
        usart_periph = UART1;
    } else if (port_id == TUYA_UART_NUM_2) {
        usart_periph = UART2;
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    usart_deinit(usart_periph);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief uart write data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] data: write buff
 * @param[in] len:  buff len
 *
 * @return return > 0: number of data written; return <= 0: write errror
 */
INT_T tkl_uart_write(TUYA_UART_NUM_E port_id, VOID_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph;
    UINT8_T *src = (UINT8_T *)buff;
    INT_T tx_count = 0;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    if (len == 0) {
        return OPRT_OS_ADAPTER_UART_SEND_FAILED;
    }

    while (1) {
        while (RESET == usart_flag_get(usart_periph, USART_FLAG_TBE));
        usart_data_transmit(usart_periph, *src++);
        len--;
        tx_count++;
        if (len == 0) {
            return tx_count;
        }
    }
    // --- END: user implements ---
}

void tuya_uart_irq_hdl(uint32_t uart)
{
    UINT8_T i;
    TUYA_UART_NUM_E port_id = TUYA_UART_NUM_MAX;

    if (uart == USART0) {
        port_id = TUYA_UART_NUM_0;
    } else if (uart == UART1) {
        port_id = TUYA_UART_NUM_1;
    } else if (uart == UART2) {
        port_id = TUYA_UART_NUM_2;
    } else {
        return;
    }

    if (RESET != usart_interrupt_flag_get(USART0, USART_INT_FLAG_TC)) {
        usart_interrupt_disable(uart, USART_INT_TC);
        for (i = 0; i < TUYA_UART_NUM_MAX; i++) {
            if (uart_tx_cbs[i].port_id == port_id && uart_tx_cbs[i].callback != NULL) {
                uart_tx_cbs[i].callback(port_id);
                break;
            }
        }
        usart_interrupt_enable(uart, USART_INT_TC);
        return;
    }

    if (RESET != usart_interrupt_flag_get(USART0, USART_INT_FLAG_RBNE)) {
        usart_interrupt_disable(uart, USART_INT_RBNE);
        for (i = 0; i < TUYA_UART_NUM_MAX; i++) {
            if (uart_rx_cbs[i].port_id == port_id && uart_rx_cbs[i].callback != NULL) {
                uart_rx_cbs[i].callback(port_id);
                break;
            }
        }
        usart_interrupt_enable(uart, USART_INT_RBNE);
        return;
    }
    return;
}


/**
 * @brief enable uart rx interrupt and regist interrupt callback
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
VOID_T tkl_uart_rx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB rx_cb)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph = USART0;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
        eclic_irq_enable(USART0_IRQn, 8, 0);
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
        eclic_irq_enable(UART1_IRQn, 8, 0);
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
        eclic_irq_enable(UART2_IRQn, 8, 0);
    } else {
        return ;
    }

    if (tuya_uart_irq_callback_register(port_id, rx_cb, 0) == TRUE)
        usart_interrupt_enable(usart_periph, USART_INT_RBNE);

    return ;
    // --- END: user implements ---
}

/**
 * @brief regist uart tx interrupt callback
 * If this function is called, it indicates that the data is sent asynchronously through interrupt,
 * and then write is invoked to initiate asynchronous transmission.
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] rx_cb: receive callback
 *
 * @return none
 */
VOID_T tkl_uart_tx_irq_cb_reg(TUYA_UART_NUM_E port_id, TUYA_UART_IRQ_CB tx_cb)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph = USART0;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
        eclic_irq_enable(USART0_IRQn, 8, 0);
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
        eclic_irq_enable(UART1_IRQn, 8, 0);
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
        eclic_irq_enable(UART2_IRQn, 8, 0);
    } else {
        return ;
    }

    if (tuya_uart_irq_callback_register(port_id, tx_cb, 1) == TRUE)
        usart_interrupt_enable(usart_periph, USART_INT_TC);

    return ;
    // --- END: user implements ---
}

/**
 * @brief uart read data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[out] data: read data
 * @param[in] len:  buff len
 *
 * @return return >= 0: number of data read; return < 0: read errror
 */
INT_T tkl_uart_read(TUYA_UART_NUM_E port_id, VOID_T *buff, UINT16_T len)
{
    // --- BEGIN: user implements ---
    CHAR_T *rx_buf = (CHAR_T *)buff;
    CHAR_T ch = 0;
    INT_T cnt = 0;
    UINT_T usart_periph;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    while (1)
    {
        if (RESET != usart_flag_get(usart_periph, USART_FLAG_ORERR)) {
            usart_flag_clear(usart_periph, USART_FLAG_ORERR);
        }

        if ((RESET != usart_flag_get(usart_periph, USART_FLAG_RBNE))) {
            ch = (CHAR_T)usart_data_receive(usart_periph);
        } else {
            break;
        }

        if (cnt < len) {
            rx_buf[cnt] = ch;
            cnt++;
        }
        if (cnt >= len)
            break;
    }

    return cnt;
    // --- END: user implements ---
}

/**
 * @brief set uart transmit interrupt status
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe tx int, FALSE-disable tx int
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_tx_int(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    if (enable) {
        usart_interrupt_enable(usart_periph, USART_INT_TC);
    } else {
        usart_interrupt_disable(usart_periph, USART_INT_TC);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set uart receive flowcontrol
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] enable: TRUE-enalbe rx flowcontrol, FALSE-disable rx flowcontrol
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_set_rx_flowctrl(TUYA_UART_NUM_E port_id, BOOL_T enable)
{
    // --- BEGIN: user implements ---
    UINT_T usart_periph;

    if ((port_id & 0xffff) == TUYA_UART_NUM_0) {
        usart_periph = USART0;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_1) {
        usart_periph = UART1;
    } else if ((port_id & 0xffff) == TUYA_UART_NUM_2) {
        usart_periph = UART2;
    } else {
        return OPRT_OS_ADAPTER_UART_INIT_FAILED;
    }

    // only RTS_CTS flowcontrol supported
    if (enable) {
        usart_hardware_flow_rts_config(usart_periph, USART_RTS_ENABLE);
        usart_hardware_flow_cts_config(usart_periph, USART_CTS_ENABLE);
    } else {
        usart_hardware_flow_rts_config(usart_periph, USART_RTS_DISABLE);
        usart_hardware_flow_cts_config(usart_periph, USART_CTS_DISABLE);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief wait for uart data
 *
 * @param[in] port_id: uart port id, id index starts at 0
 *                     in linux platform,
 *                         high 16 bits aslo means uart type,
 *                                   it's value must be one of the TUYA_UART_TYPE_E type
 *                         the low 16bit - means uart port id
 *                         you can input like this TUYA_UART_PORT_ID(TUYA_UART_SYS, 2)
 * @param[in] timeout_ms: the max wait time, unit is millisecond
 *                        -1 : block indefinitely
 *                        0  : non-block
 *                        >0 : timeout in milliseconds
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_wait_for_data(TUYA_UART_NUM_E port_id, INT_T timeout_ms)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

/**
 * @brief uart control
 *
 * @param[in] uart refer to tuya_uart_t
 * @param[in] cmd control command
 * @param[in] arg command argument
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_uart_ioctl(TUYA_UART_NUM_E port_id, UINT32_T cmd, VOID *arg)
{
    // --- BEGIN: user implements ---
    return OPRT_NOT_SUPPORTED;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
