/**
 * @file tkl_wifi.c
 * @brief this file was auto-generated by tuyaos v&v tools, developer can add implements between BEGIN and END
 *
 * @warning: changes between user 'BEGIN' and 'END' will be keeped when run tuyaos v&v tools
 *           changes in other place will be overwrited and lost
 *
 * @copyright Copyright 2020-2021 Tuya Inc. All Rights Reserved.
 *
 */

// --- BEGIN: user defines and implements ---
#include "wlan_config.h"
#include "wifi_management.h"
#include "wrapper_freertos.h"
#include "macif_types.h"
#include "wifi_net_ip.h"
#include "wifi_vif.h"
#include "wifi_management.h"
#include "wifi_netlink.h"
#include "lwip/inet.h"
#include "dhcpd.h"
#include "tkl_memory.h"
#include "tkl_wifi.h"
#include "tkl_output.h"
#include "tuya_error_code.h"

#ifdef TUYAOS_SUPPORT

typedef struct {
    CHAR_T   ssid[WIFI_SSID_LEN + 1];       // ssid
    UCHAR_T  passwd[WIFI_PASSWD_LEN + 1];   // password
    UINT32_T akm;                           // auth mode
    UCHAR_T  channel;                       // channel
    UINT32_T ip_goted;                      // last got ip
}FAST_WF_CONNECTED_AP_INFO_S;

static WIFI_EVENT_CB tkl_wifi_event_callback = NULL;
static SNIFFER_CALLBACK tkl_wifi_sniffer_cb = NULL;
static WIFI_REV_MGNT_CB tkl_wifi_recv_cb = NULL;

extern uint16_t mgmt_wait_queue_fetch(uint8_t vif_idx, uint8_t evt, uint32_t timeout_ms);
extern int mgmt_wait_queue_flush(void);

static void tkl_wifi_connected_callback(void *eloop_data, void *user_ctx)
{
    tkl_wifi_event_callback(WFE_CONNECTED, NULL);
    // printf("--------------------------connect success\r\n");
}

static void tkl_wifi_disconnected_callback(void *eloop_data, void *user_ctx)
{
    tkl_wifi_event_callback(WFE_DISCONNECTED, NULL);
    // printf("--------------------------disconnected\r\n");
}

extern wifi_management_sm_data_t wifi_sm_data[CFG_VIF_NUM];
static void tkl_wifi_connect_failed_callback(void *eloop_data, void *user_ctx)
{
    if (wifi_sm_data[0].retry_count == 0 && wifi_sm_data[0].MAINTAIN_CONNECTION_state == MAINTAIN_CONNECTION_IDLE) {
        if (NULL != tkl_wifi_event_callback) {
            // printf("--------------------------connect fail\r\n");
            tkl_wifi_event_callback(WFE_CONNECT_FAILED, NULL);
        }
    }
}

static void wifi_event_register(void)
{
    eloop_event_register(WIFI_MGMT_EVENT_DHCP_SUCCESS, tkl_wifi_connected_callback, NULL, NULL);
    eloop_event_register(WIFI_MGMT_EVENT_CONNECT_FAIL, tkl_wifi_connect_failed_callback, NULL, NULL);
    eloop_event_register(WIFI_MGMT_EVENT_DISCONNECT, tkl_wifi_disconnected_callback, NULL, NULL);
}

static void wifi_event_unregister(void)
{
    eloop_event_unregister(WIFI_MGMT_EVENT_DHCP_SUCCESS);
    eloop_event_unregister(WIFI_MGMT_EVENT_CONNECT_FAIL);
    eloop_event_unregister(WIFI_MGMT_EVENT_DISCONNECT);
}
// --- END: user defines and implements ---

/**
 * @brief set wifi station work status changed callback
 *
 * @param[in]      cb        the wifi station work status changed callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_init(WIFI_EVENT_CB cb)
{
    // --- BEGIN: user implements ---
    tkl_wifi_event_callback = cb;

    wifi_event_unregister();
    wifi_event_register();

#if 0
    if (wifi_init(true)) {
        return OPRT_OK;
    } else {
        return OPRT_COM_ERROR;
    }
#endif
    return OPRT_OK;
    // --- END: user implements ---
}

#if 0// scan not block
typedef struct {
    AP_IF_S         **ap_if;
    unsigned char   ap_if_count;
} SACN_AP_RESULTS_T;

static void tkl_wifi_scan_results_get(SACN_AP_RESULTS_T *scan_res)
{
    struct mac_scan_result result = {0};
    INT32_T result_cnt = 0;
    AP_IF_S *ap_info = NULL;

    while (wifi_management_scan_result_get(result_cnt, &result)) {
        ap_info = sys_zalloc(sizeof(AP_IF_S));
        if (ap_info == NULL)
            break;
        scan_result_transfer(&result, ap_info);
        print_ap_info(ap_info);
        sys_memset(&result, 0, sizeof(result));
        scan_res->ap_if[result_cnt] = ap_info;
        result_cnt++;
    }
    scan_res->ap_if_count = result_cnt;
}

static void _scan_done_cb(void *eloop_data, void *user_ctx)
{
    SACN_AP_RESULTS_T *scan_res = (SACN_AP_RESULTS_T *)user_ctx;

    tkl_log_output("scan succeed\r\n");

    tkl_wifi_scan_results_get(scan_res);

    eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_DONE);
    eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_FAIL);
}

static void _scan_fail_cb(void *eloop_data, void *user_ctx)
{
    tkl_log_output("tkl_wifi_scan_ap: failed\r\n");
    eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_DONE);
    eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_FAIL);
}
#endif

static void scan_result_transfer(struct mac_scan_result *result, AP_IF_S *ap_info)
{
    sys_memset(ap_info, 0, sizeof(AP_IF_S));
    ap_info->channel = ((result->chan->freq - 2412) / 5) + 1;
    ap_info->rssi = result->rssi;
    sys_memcpy(ap_info->bssid, (UCHAR_T *)result->bssid.array, 6);
    sys_memcpy(ap_info->ssid, result->ssid.array, result->ssid.length);
    ap_info->s_len = result->ssid.length;
    if (result->akm == CO_BIT(MAC_AKM_NONE)) {
        ap_info->security = WAAM_OPEN;
    } else if (result->akm == CO_BIT(MAC_AKM_PRE_RSN)) {
        ap_info->security = WAAM_WEP;
    } else if (result->akm == (CO_BIT(MAC_AKM_PRE_RSN) | CO_BIT(MAC_AKM_PSK))) {
        ap_info->security = WAAM_WPA_PSK;
    } else if (result->akm == CO_BIT(MAC_AKM_PSK)) {
        ap_info->security = WAAM_WPA2_PSK;//same as wpa2 wpa mix
    } else if (result->akm & CO_BIT(MAC_AKM_SAE)) {
        ap_info->security = WAAM_WPA_WPA3_SAE;
    }
}

/**
 * @brief scan current environment and obtain the ap
 *        infos in current environment
 *
 * @param[in]       ssid        the specific ssid
 * @param[out]      ap_ary      current ap info array
 * @param[out]      num         the num of ar_ary
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 *
 * @note if ssid == NULL means scan all ap, otherwise means scan the specific ssid
 */
OPERATE_RET tkl_wifi_scan_ap(CONST SCHAR_T *ssid, AP_IF_S **ap_ary, UINT_T *num)
{
    // --- BEGIN: user implements ---
#if 0 // scan not block
    SACN_AP_RESULTS_T *scan_res = tkl_system_malloc(sizeof(SACN_AP_RESULTS_T));

    if (NULL == scan_res)
        return OPRT_MALLOC_FAILED;
#endif
    struct macif_scan_results *results = NULL;
    INT8_T i = 0;
    AP_IF_S *ap_info = NULL;

    if (NULL == ap_ary || NULL == num) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    results = (struct macif_scan_results *)tkl_system_malloc(sizeof(struct macif_scan_results));
    if (NULL == results)
        return OPRT_MALLOC_FAILED;

    // scan not block
    // eloop_event_register(WIFI_MGMT_EVENT_SCAN_DONE, _scan_done_cb, NULL, scan_res);
    // eloop_event_register(WIFI_MGMT_EVENT_SCAN_FAIL, _scan_fail_cb, NULL, NULL);
    if (wifi_management_scan(true, (const CHAR_T *)ssid) == -1) {
        // scan not block
        // eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_DONE);
        // eloop_event_unregister(WIFI_MGMT_EVENT_SCAN_FAIL);
        tkl_log_output("Wifi scan failed\r\n");
        return OPRT_OS_ADAPTER_AP_SCAN_FAILED;
    }

    if (wifi_netlink_scan_results_get(WIFI_VIF_INDEX_DEFAULT, results)) {
        return OPRT_OS_ADAPTER_AP_SCAN_FAILED;
    }

    ap_info = sys_zalloc(sizeof(AP_IF_S) * results->result_cnt);
    if (ap_info == NULL) {
        *num = 0;
        return OPRT_MALLOC_FAILED;
    }

    for (i = 0; i < results->result_cnt; i++) {
        scan_result_transfer((results->result + i), &ap_info[i]);
    }
    *num = results->result_cnt;
    *ap_ary = ap_info;

    tkl_system_free(results);
    // scan not block
    // tkl_system_free(scan_res);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief release the memory malloced in <tkl_wifi_ap_scan>
 *        if needed. tuyaos will call this function when the
 *        ap info is no use.
 *
 * @param[in]       ap          the ap info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_release_ap(AP_IF_S *ap)
{
    // --- BEGIN: user implements ---
    if (NULL == ap) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    tkl_system_free(ap);
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief start a soft ap
 *
 * @param[in]       cfg         the soft ap config
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_start_ap(CONST WF_AP_CFG_IF_S *cfg)
{
    // --- BEGIN: user implements ---
    UINT32_T auth_mode = 0;

    if (NULL == cfg) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (cfg->md == WAAM_OPEN) {
        auth_mode = AUTH_MODE_OPEN;
    } else if (cfg->md == WAAM_WEP) {
        auth_mode = AUTH_MODE_WEP;
    } else if (cfg->md == WAAM_WPA_PSK) {
        auth_mode = AUTH_MODE_WPA;
    } else if (cfg->md == WAAM_WPA2_PSK) {
        auth_mode = AUTH_MODE_WPA2;
    } else if (cfg->md == WAAM_WPA_WPA2_PSK) {
        auth_mode = AUTH_MODE_WPA_WPA2;
    } else if (cfg->md == WAAM_WPA_WPA3_SAE) {
        auth_mode = AUTH_MODE_WPA3;
    } else {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_management_ap_start((CHAR_T *)cfg->ssid, (CHAR_T *)cfg->passwd, cfg->chan, auth_mode, cfg->ssid_hidden)) {
        return OPRT_OS_ADAPTER_AP_START_FAILED;
    }

    tkl_wifi_set_ip(WF_AP, (NW_IP_S *)&cfg->ip);

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief stop a soft ap
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_stop_ap(VOID_T)
{
    // --- BEGIN: user implements ---
    if (wifi_management_ap_stop()) {
        return OPRT_OS_ADAPTER_AP_STOP_FAILED;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi interface work channel
 *
 * @param[in]       chan        the channel to set
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_cur_channel(CONST UCHAR_T chan)
{
    // --- BEGIN: user implements ---
    if (chan == 0 || chan > 14)
        return OPRT_INVALID_PARM;

    if (wifi_netlink_channel_set(chan)) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi interface work channel
 *
 * @param[out]      chan        the channel wifi works
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_cur_channel(UCHAR_T *chan)
{
    // --- BEGIN: user implements ---
    UINT8_T cur_channel = 0;

    if (chan == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }
    if (macif_vif_current_chan_get(WIFI_VIF_INDEX_STA_MODE, &cur_channel))
        return OPRT_OS_ADAPTER_CHAN_GET_FAILED;

    *chan = cur_channel;

    return OPRT_OK;
    // --- END: user implements ---
}

static void sniffer_cb_transfer(struct wifi_frame_info *info, void *arg)
{
    if (NULL != tkl_wifi_sniffer_cb) {
        tkl_wifi_sniffer_cb(info->payload, info->length, info->rssi);
    }
}

/**
 * @brief enable / disable wifi sniffer mode.
 *        if wifi sniffer mode is enabled, wifi recv from
 *        packages from the air, and user shoud send these
 *        packages to tuya-sdk with callback <cb>.
 *
 * @param[in]       en          enable or disable
 * @param[in]       cb          notify callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_sniffer(CONST BOOL_T en, CONST SNIFFER_CALLBACK cb)
{
    // --- BEGIN: user implements ---
    UINT8_T channel = 0;

    if (en) {
        if (NULL == cb) {
            return OPRT_OS_ADAPTER_INVALID_PARM;
        }

        tkl_wifi_sniffer_cb = cb;
        tkl_wifi_get_cur_channel(&channel);
        if (wifi_management_monitor_start(channel, sniffer_cb_transfer))
            return OPRT_OS_ADAPTER_SNIFFER_SET_FAILED;
    } else {
        wifi_management_sta_start();
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi ip info.when wifi works in
 *        ap+station mode, wifi has two ips.
 *
 * @param[in]       wf          wifi function type
 * @param[out]      ip          the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    OPERATE_RET fvif_idx = WIFI_VIF_INDEX_DEFAULT;
    struct wifi_ip_addr_cfg cfg = {0};

    if (ip == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_management_concurrent_get()) {
        if (wf == WF_STATION) {
            fvif_idx = WIFI_VIF_INDEX_STA_MODE;
        } else {
            fvif_idx = WIFI_VIF_INDEX_SOFTAP_MODE;
        }
    }

    if (!wifi_get_vif_ip(fvif_idx, &cfg)) {
        inet_ntoa_r(cfg.ipv4.addr, ip->ip, 16);
        inet_ntoa_r(cfg.ipv4.gw, ip->gw, 16);
        inet_ntoa_r(cfg.ipv4.mask, ip->mask, 16);
        return OPRT_OK;
    }
    return OPRT_COM_ERROR;
    // --- END: user implements ---
}

/**
 * @brief wifi set ip
 *
 * @param[in]       wf     wifi function type
 * @param[in]       ip     the ip addr info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_ip(CONST WF_IF_E wf, NW_IP_S *ip)
{
    // --- BEGIN: user implements ---
    OPERATE_RET fvif_idx = WIFI_VIF_INDEX_DEFAULT;
    struct wifi_ip_addr_cfg ip_cfg = {0};
    struct wifi_vif_tag *wvif = NULL;

    if (ip == NULL)
        goto Fail;

    if (wifi_management_concurrent_get()) {
        fvif_idx = WIFI_VIF_INDEX_SOFTAP_MODE;
    } else {
        fvif_idx = WIFI_VIF_INDEX_STA_MODE;
    }

    wvif = vif_idx_to_wvif(fvif_idx);

    if (wf == WF_STATION) {
        ip_cfg.mode = IP_ADDR_STATIC_IPV4;
        net_if_use_static_ip(true);
    } else if (wf == WF_AP) {
        if (wvif->wvif_type != WVIF_AP) {
            tkl_log_output("wifi_set_ip: only for AP mode\r\n");
            goto Fail;
        }
        ip_cfg.mode = IP_ADDR_DHCP_SERVER;
    }

    if (!inet_aton(ip->ip, (UINT32_T *)&ip_cfg.ipv4.addr))
        goto Fail;
    if (!inet_aton(ip->gw, (UINT32_T *)&ip_cfg.ipv4.gw))
        goto Fail;
    if (!inet_aton(ip->mask, (UINT32_T *)&ip_cfg.ipv4.mask))
        goto Fail;

    if (!wifi_set_vif_ip(fvif_idx, &ip_cfg))
        return OPRT_OK;

    return OPRT_COM_ERROR;

Fail:
    return OPRT_OS_ADAPTER_INVALID_PARM;
    // --- END: user implements ---
}

/**
 * @brief set wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 *
 * @param[in]       wf          wifi function type
 * @param[in]       mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_mac(CONST WF_IF_E wf, CONST NW_MAC_S *mac)
{
    // --- BEGIN: user implements ---
    wifi_netlink_wifi_close();
    wifi_vif_user_addr_set((UINT8_T *)mac->mac);
    wifi_netlink_wifi_open();
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi mac info.when wifi works in
 *        ap+station mode, wifi has two macs.
 *
 * @param[in]       wf          wifi function type
 * @param[out]      mac         the mac info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_mac(CONST WF_IF_E wf, NW_MAC_S *mac)
{
    // --- BEGIN: user implements ---
    INT32_T fvif_idx = WIFI_VIF_INDEX_DEFAULT;
    UINT8_T *mac_addr = NULL;

    if (mac == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

#ifdef CFG_WIFI_CONCURRENT
    if (wf == WF_STATION) {
        fvif_idx = WIFI_VIF_INDEX_STA_MODE;
    } else {
        fvif_idx = WIFI_VIF_INDEX_SOFTAP_MODE;
    }
#endif

    mac_addr = wifi_vif_mac_addr_get(fvif_idx);
    if (mac_addr == NULL) {
        return OPRT_OS_ADAPTER_MAC_GET_FAILED;
    } else {
        sys_memcpy(mac->mac, mac_addr, MAC_ADDR_LEN);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi work mode
 *
 * @param[in]       mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_work_mode(CONST WF_WK_MD_E mode)
{
    // --- BEGIN: user implements ---
#ifdef CFG_WIFI_CONCURRENT
    if (mode == WWM_STATIONAP) {
        wifi_management_concurrent_set(1);
        if (eloop_message_send(WIFI_VIF_INDEX_STA_MODE, WIFI_MGMT_EVENT_SWITCH_MODE_CMD, WVIF_STA, NULL, 0)) {
            return OPRT_OS_ADAPTER_WORKMODE_SET_FAILED;
        }
        if (eloop_message_send(WIFI_VIF_INDEX_SOFTAP_MODE, WIFI_MGMT_EVENT_SWITCH_MODE_CMD, WWM_SOFTAP, NULL, 0)) {
            return OPRT_OS_ADAPTER_WORKMODE_SET_FAILED;
        }
        return OPRT_OK;
    }
#endif

    enum wifi_vif_type vif_mode = WVIF_UNKNOWN;
    switch (mode) {
    case WWM_STATION:
        vif_mode = WVIF_STA;
        break;
    case WWM_SOFTAP:
        vif_mode = WVIF_AP;
        break;
    case WWM_SNIFFER:
        vif_mode = WVIF_MONITOR;
        break;
    case WWM_UNKNOWN:
        vif_mode = WVIF_UNKNOWN;
        break;
    case WWM_POWERDOWN:
        vif_mode = WVIF_UNKNOWN;
        break;
    case WWM_STATIONAP:
    default:
        break;
    }

    if (eloop_message_send(WIFI_VIF_INDEX_DEFAULT, WIFI_MGMT_EVENT_SWITCH_MODE_CMD, vif_mode, NULL, 0)) {
        return OPRT_OS_ADAPTER_WORKMODE_SET_FAILED;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi work mode
 *
 * @param[out]      mode        wifi work mode
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_work_mode(WF_WK_MD_E *mode)
{
    // --- BEGIN: user implements ---
    struct wifi_vif_tag *wvif = (struct wifi_vif_tag *)vif_idx_to_wvif(WIFI_VIF_INDEX_DEFAULT);

    if (mode == NULL) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

#ifdef CFG_WIFI_CONCURRENT
    if (wifi_management_concurrent_get()) {
        *mode = WWM_STATIONAP;
        return OPRT_OK;
    }
#endif

    switch (wvif->wvif_type) {
    case WVIF_STA:
        *mode = WWM_STATION;
        break;
    case WVIF_AP:
        *mode = WWM_SOFTAP;
        break;
    case WVIF_MONITOR:
        *mode = WWM_SNIFFER;
        break;
    case WVIF_UNKNOWN:
        *mode = WWM_STATION;
        break;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief : get ap info for fast connect
 * @param[out]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_connected_ap_info(FAST_WF_CONNECTED_AP_INFO_T **fast_ap_info)
{
    // --- BEGIN: user implements ---
    FAST_WF_CONNECTED_AP_INFO_T *ap_info_buf = NULL;
    UINT32_T len = sizeof(FAST_WF_CONNECTED_AP_INFO_S);
    FAST_WF_CONNECTED_AP_INFO_S ap_info = {0};
    struct wifi_vif_tag *wvif = (struct wifi_vif_tag *)vif_idx_to_wvif(WIFI_VIF_INDEX_DEFAULT);
    struct wifi_sta *sta = NULL;
    WF_STATION_STAT_E stat;

    if (NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (NULL == wvif) {
        return OPRT_OS_ADAPTER_APINFO_GET_FAILED;
    }
    tkl_wifi_station_get_status(&stat);

    if (stat != WSS_GOT_IP) {
        return OPRT_OS_ADAPTER_APINFO_GET_FAILED;
    }

    sta = &wvif->sta;

    ap_info_buf = (FAST_WF_CONNECTED_AP_INFO_T *)tkl_system_malloc(sizeof(FAST_WF_CONNECTED_AP_INFO_T) + len);
    if (NULL == ap_info_buf) {
        return OPRT_OS_ADAPTER_MALLOC_FAILED;
    }
    sys_memset(ap_info_buf, 0, sizeof(FAST_WF_CONNECTED_AP_INFO_T) + len);

    ap_info.channel = sta->cfg.channel;
    ap_info.akm = sta->cfg.akm;
    sys_memcpy(ap_info.ssid, sta->cfg.ssid, sta->cfg.ssid_len + 1);
    sys_memcpy(ap_info.passwd, sta->cfg.passphrase, sta->cfg.passphrase_len + 1);
    ap_info.ip_goted = sta->history_ip;

    ap_info_buf->len = len;
    sys_memcpy(ap_info_buf->data, &ap_info, len);

    *fast_ap_info = (void *)ap_info_buf;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi bssid
 *
 * @param[out]      mac         uplink mac
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_get_bssid(UCHAR_T *mac)
{
    // --- BEGIN: user implements ---
    struct wifi_vif_tag *wvif = (struct wifi_vif_tag *)vif_idx_to_wvif(WIFI_VIF_INDEX_DEFAULT);

    if (NULL == mac) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if ((wvif->wvif_type == WVIF_STA) && (wvif->sta.state >= WIFI_STA_STATE_CONNECT)) {
        sys_memcpy(mac, wvif->sta.cfg.bssid, MAC_ADDR_LEN);
        return OPRT_OK;
    }

    return OPRT_OS_ADAPTER_BSSID_GET_FAILED;
    // --- END: user implements ---
}

/**
 * @brief set wifi country code
 *
 * @param[in]       ccode  country code
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_country_code(CONST COUNTRY_CODE_E ccode)
{
    // --- BEGIN: user implements ---
    UINT32_T country_code = 0;

    switch (ccode) {
    case COUNTRY_CODE_CN:
        country_code = COUNTRY_CODE_SRRC;
        break;
    case COUNTRY_CODE_JP:
        country_code = COUNTRY_CODE_TELEC;
        break;
    default:
        break;
    }
    if (country_code == 0) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wifi_netlink_priv_req(WIFI_COUNTRY_CODE, country_code, 0, NULL))
        return OPRT_OS_ADAPTER_CCODE_SET_FAILE;

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief do wifi calibration
 *
 * @note called when test wifi
 *
 * @return true on success. faile on failure
 */
OPERATE_RET tkl_wifi_set_rf_calibrated(VOID_T)
{
    // --- BEGIN: user implements ---
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief set wifi lowpower mode
 *
 * @param[in]       enable      enbale lowpower mode
 * @param[in]       dtim     the wifi dtim
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_set_lp_mode(CONST BOOL_T enable, CONST UCHAR_T dtim)
{
    // --- BEGIN: user implements ---
    if (enable && ((dtim == 0) || (dtim > 10))) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (enable) {
        if (wifi_netlink_ps_mode_set(WIFI_VIF_INDEX_DEFAULT, WIFI_STA_PS_MODE_ALW_ON)) {
            return OPRT_COM_ERROR;
        }
    } else {
        if (wifi_netlink_ps_mode_set(WIFI_VIF_INDEX_DEFAULT, WIFI_STA_PS_MODE_OFF)) {
            return OPRT_COM_ERROR;
        }
    }
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief : fast connect
 * @param[in]      fast_ap_info
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_fast_connect(CONST FAST_WF_CONNECTED_AP_INFO_T *fast_ap_info)
{
    // --- BEGIN: user implements ---
    if (NULL == fast_ap_info) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    FAST_WF_CONNECTED_AP_INFO_S *connect_info = NULL;

    uint8_t vif_idx = WIFI_VIF_INDEX_DEFAULT;
    struct sta_cfg *sta_cfg = NULL;
    struct wifi_sta *sta = &(wifi_vif_tab[vif_idx].sta);
    struct sta_cfg *sta_cfg_prev = &sta->cfg;
    int reason = 0;

    WIFI_CLOSED_CHECK(1);

    connect_info = (FAST_WF_CONNECTED_AP_INFO_S *)(fast_ap_info->data);

    if (strlen((const char *)connect_info->ssid) == 0 ||
        strlen((const char *)connect_info->ssid) > WIFI_SSID_MAX_LEN) {
        tkl_log_output("MGMT: ssid is null or too long (>%d)\r\n", WIFI_SSID_MAX_LEN);
        return OPRT_INVALID_PARM;
    }

    if (((strlen((const char *)connect_info->passwd) > WPAS_MAX_PASSPHRASE_LEN) ||
        (strlen((const char *)connect_info->passwd) < WPAS_MIN_PASSPHRASE_LEN)) &&
        (strlen((const char *)connect_info->passwd) != 0)) {
        tkl_log_output("MGMT: password's length should not be greater than %d or less than %d!\r\n",
                    WPAS_MAX_PASSPHRASE_LEN, WPAS_MIN_PASSPHRASE_LEN);
        return OPRT_INVALID_PARM;
    }

    /* save connect info */
    sta_cfg = sys_zalloc(sizeof(struct sta_cfg));
    if (NULL == sta_cfg) {
        return OPRT_MALLOC_FAILED;
    }
    sta_cfg->ssid_len = strlen(connect_info->ssid);
    sys_memset(sta_cfg->ssid, 0, WIFI_SSID_MAX_LEN + 1);
    sys_memcpy(sta_cfg->ssid, connect_info->ssid, sta_cfg->ssid_len);
    if (connect_info->passwd) {
        sta_cfg->passphrase_len = strlen((const char *)connect_info->passwd);
        sys_memset(sta_cfg->passphrase, 0, WPA_MAX_PSK_LEN + 1);
        sys_memcpy(sta_cfg->passphrase, connect_info->passwd, sta_cfg->passphrase_len);
    } else {
        sta_cfg->passphrase_len = 0;
    }
    sta_cfg->channel = 0xFF;
    sta_cfg->conn_with_bssid = 0;
    sta_cfg->conn_blocked = true;
    sta->history_ip = connect_info->ip_goted;

    /* Flush wait queue */
    mgmt_wait_queue_flush();

    if (eloop_message_send(vif_idx, WIFI_MGMT_EVENT_CONNECT_CMD, 0, (uint8_t *)sta_cfg, sizeof(struct sta_cfg)) < 0) {
        sys_mfree(sta_cfg);
        tkl_log_output("MGMT: CONNECT_CMD, eloop event queue full\r\n");
        return OPRT_COM_ERROR;
    }

#if 0
    /* Block here until CONNECT related event received */
    reason = mgmt_wait_queue_fetch(vif_idx, MGMT_WAIT_EVT_CONN_DONE, WIFI_MGMT_CONNECT_RETRY_LIMIT * WIFI_MGMT_CONNECT_RETRY_INTERVAL);
    if (reason == 0xFFFF) {
        tkl_log_output("MGMT: eloop wait timeout\r\n");
    }
#endif
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief connect wifi with ssid and passwd
 *
 * @param[in]       ssid
 * @param[in]       passwd
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_connect(CONST SCHAR_T *ssid, CONST SCHAR_T *passwd)
{
    // --- BEGIN: user implements ---
    if (wifi_management_connect((CHAR_T *)ssid, (CHAR_T *)passwd, true)) {
        return OPRT_COM_ERROR;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief disconnect wifi from connect ap
 *
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_disconnect(VOID_T)
{
    // --- BEGIN: user implements ---
    wifi_management_disconnect();
    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi connect rssi
 *
 * @param[out]      rssi        the return rssi
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_conn_ap_rssi(SCHAR_T *rssi)
{
    // --- BEGIN: user implements ---
    if (NULL == rssi) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    WF_STATION_STAT_E state = 0;

    if ((tkl_wifi_station_get_status(&state) == OPRT_OK) && (state == WSS_CONN_SUCCESS || state == WSS_GOT_IP)) {
        *rssi = macif_vif_sta_rssi_get(WIFI_VIF_INDEX_DEFAULT);
    } else {
        return OPRT_OS_ADAPTER_RSSI_GET_FAILED;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief get wifi station work status
 *
 * @param[out]      stat        the wifi station work status
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_station_get_status(WF_STATION_STAT_E *stat)
{
    // --- BEGIN: user implements ---
    struct wifi_vif_tag *wvif = (struct wifi_vif_tag *)vif_idx_to_wvif(WIFI_VIF_INDEX_DEFAULT);

    if (NULL == stat) {
        return OPRT_OS_ADAPTER_INVALID_PARM;
    }

    if (wvif->wvif_type != WVIF_STA) {
        return OPRT_OS_ADAPTER_STAT_GET_FAILED;
    }

    switch (wvif->sta.state)
    {
    case WIFI_STA_STATE_IDLE:
        *stat = WSS_IDLE;
        break;
    case WIFI_STA_STATE_SCAN:
    case WIFI_STA_STATE_CONNECT:
    case WIFI_STA_STATE_HANDSHAKE:
        *stat = WSS_CONNECTING;
        break;
    case WIFI_STA_STATE_IP_GETTING:
        *stat = WSS_CONN_SUCCESS;
        break;
    case WIFI_STA_STATE_CONNECTED:
        *stat = WSS_GOT_IP;
        break;
    default:
        *stat = WSS_IDLE;
        break;
    }

    return OPRT_OK;
    // --- END: user implements ---
}

/**
 * @brief send wifi management
 *
 * @param[in]       buf         pointer to buffer
 * @param[in]       len         length of buffer
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_send_mgnt(CONST UCHAR_T *buf, CONST UINT_T len)
{
    // --- BEGIN: user implements ---
    if (wifi_send_80211_frame(WIFI_VIF_INDEX_DEFAULT, buf, len, 0, NULL, NULL) == 0)
        return OPRT_OS_ADAPTER_MGNT_SEND_FAILED;

    return OPRT_OK;
    // --- END: user implements ---
}

static void mgmt_recv_cb_transfer(struct wifi_frame_info *info, void *arg)
{
    if (NULL != tkl_wifi_recv_cb) {
        tkl_wifi_recv_cb(info->payload, info->length);
    }
}

/**
 * @brief register receive wifi management callback
 *
 * @param[in]       enable
 * @param[in]       recv_cb     receive callback
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_register_recv_mgnt_callback(CONST BOOL_T enable, CONST WIFI_REV_MGNT_CB recv_cb)
{
    // --- BEGIN: user implements ---
    if (enable) {
        tkl_wifi_recv_cb = recv_cb;
        macif_rx_set_mgmt_cb(mgmt_recv_cb_transfer, NULL);
    } else {
        tkl_wifi_recv_cb = NULL;
        macif_rx_set_mgmt_cb(NULL, NULL);
    }

    return OPRT_OK;
    // --- END: user implements ---
}

static OPERATE_RET tkl_wifi_get_all_sta_info(WF_STA_INFO_S **sta_ary, UINT_T *num)
{
    OPERATE_RET ret = OPRT_OK;
    WF_STA_INFO_S *p_sta = NULL, *temp = NULL;
    struct mac_addr cli_mac[CFG_STA_NUM];
    INT32_T cli_num = 0, j = 0;
    INT32_T fvif_idx = WIFI_VIF_INDEX_DEFAULT;
    UINT32_T ip_addr = 0;

    if (sta_ary == NULL || num == NULL)
        return OPRT_INVALID_PARM;

    cli_num = macif_vif_ap_assoc_info_get(fvif_idx, (uint16_t *)&cli_mac);
    if (cli_num != 0) {
        p_sta = tkl_system_malloc(cli_num * sizeof(WF_STA_INFO_S));
        if (p_sta == NULL) {
            ret = OPRT_MALLOC_FAILED;
        } else {
            for (j = 0; j < cli_num; j++, ip_addr = 0) {
                temp = &p_sta[j];
                memcpy(temp->sta_mac.mac, (UINT8_T *)cli_mac[j].array, MAC_ADDR_LEN);
                // get ap's gateway adn ip mask
                tkl_wifi_get_ip(WF_AP, &temp->sta_ip);
                // get one sta's ip addr
                ip_addr = dhcpd_find_ipaddr_by_macaddr((uint8_t *)cli_mac[j].array);
                if (ip_addr != 0) {
                    snprintf(temp->sta_ip.ip, 16, "%ld.%ld.%ld.%ld",
                        (ip_addr >> 0) & 0xff, (ip_addr >> 8) & 0xff, (ip_addr >> 16) & 0xff, (ip_addr >> 24) & 0xff);
                }
            }
        }
    } else if (cli_num == 0) {
            // Not found, do nothing
    }

    *num = cli_num;
    *sta_ary = p_sta;

    return ret;
}

/**
 * @brief wifi ioctl
 *
 * @param[in]       cmd     refer to WF_IOCTL_CMD_E
 * @param[in]       args    args associated with the command
 * @return OPRT_OK on success. Others on error, please refer to tuya_error_code.h
 */
OPERATE_RET tkl_wifi_ioctl(WF_IOCTL_CMD_E cmd, VOID *args)
{
    // --- BEGIN: user implements ---
    OPERATE_RET ret = OPRT_NOT_SUPPORTED;

    switch (cmd) {
    case WFI_AP_GET_STALIST_CMD:
        {
            WF_STA_LIST_S *list = (WF_STA_LIST_S *)args;
            ret = tkl_wifi_get_all_sta_info(&list->array, &list->num);
            // for (int i = 0; i < list->num; i++) {
            //     printf("\tclient[%d]: "MAC_FMT" ip:%s\r\n",i, MAC_ARG_UINT8(list->array[i].sta_mac.mac), list->array[i].sta_ip.ip);
            // }
            break;
        }
    default:
        break;
    }

    return ret;
    // --- END: user implements ---
}

#endif /* TUYAOS_SUPPORT */
